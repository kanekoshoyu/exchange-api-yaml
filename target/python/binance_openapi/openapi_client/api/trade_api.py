# coding: utf-8

"""
    Binance Public Spot API

    OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.account import Account
from openapi_client.models.api_v3_account_commission_get200_response import ApiV3AccountCommissionGet200Response
from openapi_client.models.api_v3_all_order_list_get200_response_inner import ApiV3AllOrderListGet200ResponseInner
from openapi_client.models.api_v3_my_allocations_get200_response_inner import ApiV3MyAllocationsGet200ResponseInner
from openapi_client.models.api_v3_my_prevented_matches_get200_response_inner import ApiV3MyPreventedMatchesGet200ResponseInner
from openapi_client.models.api_v3_open_order_list_get200_response_inner import ApiV3OpenOrderListGet200ResponseInner
from openapi_client.models.api_v3_open_orders_delete200_response_inner import ApiV3OpenOrdersDelete200ResponseInner
from openapi_client.models.api_v3_order_cancel_replace_post200_response import ApiV3OrderCancelReplacePost200Response
from openapi_client.models.api_v3_order_list_get200_response import ApiV3OrderListGet200Response
from openapi_client.models.api_v3_order_oco_post200_response import ApiV3OrderOcoPost200Response
from openapi_client.models.api_v3_order_post200_response import ApiV3OrderPost200Response
from openapi_client.models.api_v3_rate_limit_order_get200_response_inner import ApiV3RateLimitOrderGet200ResponseInner
from openapi_client.models.api_v3_sor_order_post200_response import ApiV3SorOrderPost200Response
from openapi_client.models.my_trade import MyTrade
from openapi_client.models.oco_order import OcoOrder
from openapi_client.models.order import Order
from openapi_client.models.order_details import OrderDetails

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class TradeApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def api_v3_account_commission_get(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiV3AccountCommissionGet200Response:
        """Query Commission Rates (USER_DATA)

        Get current account commission rates.  Weight: 20

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_account_commission_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3AccountCommissionGet200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_account_commission_get_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApiV3AccountCommissionGet200Response]:
        """Query Commission Rates (USER_DATA)

        Get current account commission rates.  Weight: 20

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_account_commission_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3AccountCommissionGet200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_account_commission_get_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Commission Rates (USER_DATA)

        Get current account commission rates.  Weight: 20

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_account_commission_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3AccountCommissionGet200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_account_commission_get_serialize(
        self,
        symbol,
        timestamp,
        signature,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/account/commission',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_account_get(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Account:
        """Account Information (USER_DATA)

        Get current account information.  Weight(IP): 20

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_account_get_serialize(
            timestamp=timestamp,
            signature=signature,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Account",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_account_get_with_http_info(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Account]:
        """Account Information (USER_DATA)

        Get current account information.  Weight(IP): 20

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_account_get_serialize(
            timestamp=timestamp,
            signature=signature,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Account",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_account_get_without_preload_content(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Account Information (USER_DATA)

        Get current account information.  Weight(IP): 20

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_account_get_serialize(
            timestamp=timestamp,
            signature=signature,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Account",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_account_get_serialize(
        self,
        timestamp,
        signature,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/account',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_all_order_list_get(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        from_id: Annotated[Optional[StrictInt], Field(description="Trade id to fetch from. Default gets most recent trades.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApiV3AllOrderListGet200ResponseInner]:
        """Query all OCO (USER_DATA)

        Retrieves all OCO based on provided optional parameters  Weight(IP): 20

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param from_id: Trade id to fetch from. Default gets most recent trades.
        :type from_id: int
        :param start_time: UTC timestamp in ms
        :type start_time: int
        :param end_time: UTC timestamp in ms
        :type end_time: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_all_order_list_get_serialize(
            timestamp=timestamp,
            signature=signature,
            from_id=from_id,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3AllOrderListGet200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_all_order_list_get_with_http_info(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        from_id: Annotated[Optional[StrictInt], Field(description="Trade id to fetch from. Default gets most recent trades.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ApiV3AllOrderListGet200ResponseInner]]:
        """Query all OCO (USER_DATA)

        Retrieves all OCO based on provided optional parameters  Weight(IP): 20

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param from_id: Trade id to fetch from. Default gets most recent trades.
        :type from_id: int
        :param start_time: UTC timestamp in ms
        :type start_time: int
        :param end_time: UTC timestamp in ms
        :type end_time: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_all_order_list_get_serialize(
            timestamp=timestamp,
            signature=signature,
            from_id=from_id,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3AllOrderListGet200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_all_order_list_get_without_preload_content(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        from_id: Annotated[Optional[StrictInt], Field(description="Trade id to fetch from. Default gets most recent trades.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query all OCO (USER_DATA)

        Retrieves all OCO based on provided optional parameters  Weight(IP): 20

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param from_id: Trade id to fetch from. Default gets most recent trades.
        :type from_id: int
        :param start_time: UTC timestamp in ms
        :type start_time: int
        :param end_time: UTC timestamp in ms
        :type end_time: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_all_order_list_get_serialize(
            timestamp=timestamp,
            signature=signature,
            from_id=from_id,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3AllOrderListGet200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_all_order_list_get_serialize(
        self,
        timestamp,
        signature,
        from_id,
        start_time,
        end_time,
        limit,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if from_id is not None:
            
            _query_params.append(('fromId', from_id))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/allOrderList',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_all_orders_get(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_id: Annotated[Optional[StrictInt], Field(description="Order id")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[OrderDetails]:
        """All Orders (USER_DATA)

        Get all account orders; active, canceled, or filled..  - If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time. - If `startTime` and/or `endTime` provided, `orderId` is not required  Weight(IP): 20

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_id: Order id
        :type order_id: int
        :param start_time: UTC timestamp in ms
        :type start_time: int
        :param end_time: UTC timestamp in ms
        :type end_time: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_all_orders_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            order_id=order_id,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OrderDetails]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_all_orders_get_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_id: Annotated[Optional[StrictInt], Field(description="Order id")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[OrderDetails]]:
        """All Orders (USER_DATA)

        Get all account orders; active, canceled, or filled..  - If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time. - If `startTime` and/or `endTime` provided, `orderId` is not required  Weight(IP): 20

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_id: Order id
        :type order_id: int
        :param start_time: UTC timestamp in ms
        :type start_time: int
        :param end_time: UTC timestamp in ms
        :type end_time: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_all_orders_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            order_id=order_id,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OrderDetails]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_all_orders_get_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_id: Annotated[Optional[StrictInt], Field(description="Order id")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """All Orders (USER_DATA)

        Get all account orders; active, canceled, or filled..  - If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time. - If `startTime` and/or `endTime` provided, `orderId` is not required  Weight(IP): 20

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_id: Order id
        :type order_id: int
        :param start_time: UTC timestamp in ms
        :type start_time: int
        :param end_time: UTC timestamp in ms
        :type end_time: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_all_orders_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            order_id=order_id,
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OrderDetails]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_all_orders_get_serialize(
        self,
        symbol,
        timestamp,
        signature,
        order_id,
        start_time,
        end_time,
        limit,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/allOrders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_my_allocations_get(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        start_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        from_allocation_id: Optional[StrictInt] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default 500; max 1000.")] = None,
        order_id: Annotated[Optional[StrictInt], Field(description="Order id")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApiV3MyAllocationsGet200ResponseInner]:
        """Query Allocations (USER_DATA)

        Retrieves allocations resulting from SOR order placement.  Weight: 20  Supported parameter combinations: Parameters                            Response symbol                                allocations from oldest to newest symbol + startTime                    oldest allocations since startTime symbol + endTime                      newest allocations until endTime symbol + startTime + endTime          allocations within the time range symbol + fromAllocationId            allocations by allocation ID symbol + orderId                      allocations related to an order starting with oldest symbol + orderId + fromAllocationId  allocations related to an order by allocation ID  Note: The time between startTime and endTime can't be longer than 24 hours.

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param start_time: UTC timestamp in ms
        :type start_time: int
        :param end_time: UTC timestamp in ms
        :type end_time: int
        :param from_allocation_id:
        :type from_allocation_id: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param order_id: Order id
        :type order_id: int
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_my_allocations_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            start_time=start_time,
            end_time=end_time,
            from_allocation_id=from_allocation_id,
            limit=limit,
            order_id=order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3MyAllocationsGet200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_my_allocations_get_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        start_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        from_allocation_id: Optional[StrictInt] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default 500; max 1000.")] = None,
        order_id: Annotated[Optional[StrictInt], Field(description="Order id")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ApiV3MyAllocationsGet200ResponseInner]]:
        """Query Allocations (USER_DATA)

        Retrieves allocations resulting from SOR order placement.  Weight: 20  Supported parameter combinations: Parameters                            Response symbol                                allocations from oldest to newest symbol + startTime                    oldest allocations since startTime symbol + endTime                      newest allocations until endTime symbol + startTime + endTime          allocations within the time range symbol + fromAllocationId            allocations by allocation ID symbol + orderId                      allocations related to an order starting with oldest symbol + orderId + fromAllocationId  allocations related to an order by allocation ID  Note: The time between startTime and endTime can't be longer than 24 hours.

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param start_time: UTC timestamp in ms
        :type start_time: int
        :param end_time: UTC timestamp in ms
        :type end_time: int
        :param from_allocation_id:
        :type from_allocation_id: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param order_id: Order id
        :type order_id: int
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_my_allocations_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            start_time=start_time,
            end_time=end_time,
            from_allocation_id=from_allocation_id,
            limit=limit,
            order_id=order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3MyAllocationsGet200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_my_allocations_get_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        start_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        from_allocation_id: Optional[StrictInt] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default 500; max 1000.")] = None,
        order_id: Annotated[Optional[StrictInt], Field(description="Order id")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Allocations (USER_DATA)

        Retrieves allocations resulting from SOR order placement.  Weight: 20  Supported parameter combinations: Parameters                            Response symbol                                allocations from oldest to newest symbol + startTime                    oldest allocations since startTime symbol + endTime                      newest allocations until endTime symbol + startTime + endTime          allocations within the time range symbol + fromAllocationId            allocations by allocation ID symbol + orderId                      allocations related to an order starting with oldest symbol + orderId + fromAllocationId  allocations related to an order by allocation ID  Note: The time between startTime and endTime can't be longer than 24 hours.

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param start_time: UTC timestamp in ms
        :type start_time: int
        :param end_time: UTC timestamp in ms
        :type end_time: int
        :param from_allocation_id:
        :type from_allocation_id: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param order_id: Order id
        :type order_id: int
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_my_allocations_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            start_time=start_time,
            end_time=end_time,
            from_allocation_id=from_allocation_id,
            limit=limit,
            order_id=order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3MyAllocationsGet200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_my_allocations_get_serialize(
        self,
        symbol,
        timestamp,
        signature,
        start_time,
        end_time,
        from_allocation_id,
        limit,
        order_id,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if from_allocation_id is not None:
            
            _query_params.append(('fromAllocationId', from_allocation_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/myAllocations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_my_prevented_matches_get(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        prevented_match_id: Optional[StrictInt] = None,
        order_id: Annotated[Optional[StrictInt], Field(description="Order id")] = None,
        from_prevented_match_id: Optional[StrictInt] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApiV3MyPreventedMatchesGet200ResponseInner]:
        """Query Prevented Matches

        Displays the list of orders that were expired because of STP.  For additional information on what a Prevented match is, as well as Self Trade Prevention (STP), please refer to our STP FAQ page.  These are the combinations supported:  * symbol + preventedMatchId * symbol + orderId * symbol + orderId + fromPreventedMatchId (limit will default to 500) * symbol + orderId + fromPreventedMatchId + limit  Weight(IP):  Case                            Weight If symbol is invalid:          2 Querying by preventedMatchId:  2 Querying by orderId:            20

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param prevented_match_id:
        :type prevented_match_id: int
        :param order_id: Order id
        :type order_id: int
        :param from_prevented_match_id:
        :type from_prevented_match_id: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_my_prevented_matches_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            prevented_match_id=prevented_match_id,
            order_id=order_id,
            from_prevented_match_id=from_prevented_match_id,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3MyPreventedMatchesGet200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_my_prevented_matches_get_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        prevented_match_id: Optional[StrictInt] = None,
        order_id: Annotated[Optional[StrictInt], Field(description="Order id")] = None,
        from_prevented_match_id: Optional[StrictInt] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ApiV3MyPreventedMatchesGet200ResponseInner]]:
        """Query Prevented Matches

        Displays the list of orders that were expired because of STP.  For additional information on what a Prevented match is, as well as Self Trade Prevention (STP), please refer to our STP FAQ page.  These are the combinations supported:  * symbol + preventedMatchId * symbol + orderId * symbol + orderId + fromPreventedMatchId (limit will default to 500) * symbol + orderId + fromPreventedMatchId + limit  Weight(IP):  Case                            Weight If symbol is invalid:          2 Querying by preventedMatchId:  2 Querying by orderId:            20

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param prevented_match_id:
        :type prevented_match_id: int
        :param order_id: Order id
        :type order_id: int
        :param from_prevented_match_id:
        :type from_prevented_match_id: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_my_prevented_matches_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            prevented_match_id=prevented_match_id,
            order_id=order_id,
            from_prevented_match_id=from_prevented_match_id,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3MyPreventedMatchesGet200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_my_prevented_matches_get_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        prevented_match_id: Optional[StrictInt] = None,
        order_id: Annotated[Optional[StrictInt], Field(description="Order id")] = None,
        from_prevented_match_id: Optional[StrictInt] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Prevented Matches

        Displays the list of orders that were expired because of STP.  For additional information on what a Prevented match is, as well as Self Trade Prevention (STP), please refer to our STP FAQ page.  These are the combinations supported:  * symbol + preventedMatchId * symbol + orderId * symbol + orderId + fromPreventedMatchId (limit will default to 500) * symbol + orderId + fromPreventedMatchId + limit  Weight(IP):  Case                            Weight If symbol is invalid:          2 Querying by preventedMatchId:  2 Querying by orderId:            20

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param prevented_match_id:
        :type prevented_match_id: int
        :param order_id: Order id
        :type order_id: int
        :param from_prevented_match_id:
        :type from_prevented_match_id: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_my_prevented_matches_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            prevented_match_id=prevented_match_id,
            order_id=order_id,
            from_prevented_match_id=from_prevented_match_id,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3MyPreventedMatchesGet200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_my_prevented_matches_get_serialize(
        self,
        symbol,
        timestamp,
        signature,
        prevented_match_id,
        order_id,
        from_prevented_match_id,
        limit,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if prevented_match_id is not None:
            
            _query_params.append(('preventedMatchId', prevented_match_id))
            
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        if from_prevented_match_id is not None:
            
            _query_params.append(('fromPreventedMatchId', from_prevented_match_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/myPreventedMatches',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_my_trades_get(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_id: Annotated[Optional[StrictInt], Field(description="This can only be used in combination with symbol.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        from_id: Annotated[Optional[StrictInt], Field(description="Trade id to fetch from. Default gets most recent trades.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[MyTrade]:
        """Account Trade List (USER_DATA)

        Get trades for a specific account and symbol.  If `fromId` is set, it will get id >= that `fromId`. Otherwise most recent orders are returned.  The time between startTime and endTime can't be longer than 24 hours. These are the supported combinations of all parameters:    symbol    symbol + orderId    symbol + startTime    symbol + endTime    symbol + fromId    symbol + startTime + endTime    symbol+ orderId + fromId  Weight(IP): 20

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_id: This can only be used in combination with symbol.
        :type order_id: int
        :param start_time: UTC timestamp in ms
        :type start_time: int
        :param end_time: UTC timestamp in ms
        :type end_time: int
        :param from_id: Trade id to fetch from. Default gets most recent trades.
        :type from_id: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_my_trades_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            order_id=order_id,
            start_time=start_time,
            end_time=end_time,
            from_id=from_id,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MyTrade]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_my_trades_get_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_id: Annotated[Optional[StrictInt], Field(description="This can only be used in combination with symbol.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        from_id: Annotated[Optional[StrictInt], Field(description="Trade id to fetch from. Default gets most recent trades.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[MyTrade]]:
        """Account Trade List (USER_DATA)

        Get trades for a specific account and symbol.  If `fromId` is set, it will get id >= that `fromId`. Otherwise most recent orders are returned.  The time between startTime and endTime can't be longer than 24 hours. These are the supported combinations of all parameters:    symbol    symbol + orderId    symbol + startTime    symbol + endTime    symbol + fromId    symbol + startTime + endTime    symbol+ orderId + fromId  Weight(IP): 20

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_id: This can only be used in combination with symbol.
        :type order_id: int
        :param start_time: UTC timestamp in ms
        :type start_time: int
        :param end_time: UTC timestamp in ms
        :type end_time: int
        :param from_id: Trade id to fetch from. Default gets most recent trades.
        :type from_id: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_my_trades_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            order_id=order_id,
            start_time=start_time,
            end_time=end_time,
            from_id=from_id,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MyTrade]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_my_trades_get_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_id: Annotated[Optional[StrictInt], Field(description="This can only be used in combination with symbol.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="UTC timestamp in ms")] = None,
        from_id: Annotated[Optional[StrictInt], Field(description="Trade id to fetch from. Default gets most recent trades.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Default 500; max 1000.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Account Trade List (USER_DATA)

        Get trades for a specific account and symbol.  If `fromId` is set, it will get id >= that `fromId`. Otherwise most recent orders are returned.  The time between startTime and endTime can't be longer than 24 hours. These are the supported combinations of all parameters:    symbol    symbol + orderId    symbol + startTime    symbol + endTime    symbol + fromId    symbol + startTime + endTime    symbol+ orderId + fromId  Weight(IP): 20

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_id: This can only be used in combination with symbol.
        :type order_id: int
        :param start_time: UTC timestamp in ms
        :type start_time: int
        :param end_time: UTC timestamp in ms
        :type end_time: int
        :param from_id: Trade id to fetch from. Default gets most recent trades.
        :type from_id: int
        :param limit: Default 500; max 1000.
        :type limit: int
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_my_trades_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            order_id=order_id,
            start_time=start_time,
            end_time=end_time,
            from_id=from_id,
            limit=limit,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MyTrade]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_my_trades_get_serialize(
        self,
        symbol,
        timestamp,
        signature,
        order_id,
        start_time,
        end_time,
        from_id,
        limit,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if from_id is not None:
            
            _query_params.append(('fromId', from_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/myTrades',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_open_order_list_get(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApiV3OpenOrderListGet200ResponseInner]:
        """Query Open OCO (USER_DATA)

        Weight(IP): 6

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_open_order_list_get_serialize(
            timestamp=timestamp,
            signature=signature,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3OpenOrderListGet200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_open_order_list_get_with_http_info(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ApiV3OpenOrderListGet200ResponseInner]]:
        """Query Open OCO (USER_DATA)

        Weight(IP): 6

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_open_order_list_get_serialize(
            timestamp=timestamp,
            signature=signature,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3OpenOrderListGet200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_open_order_list_get_without_preload_content(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Open OCO (USER_DATA)

        Weight(IP): 6

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_open_order_list_get_serialize(
            timestamp=timestamp,
            signature=signature,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3OpenOrderListGet200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_open_order_list_get_serialize(
        self,
        timestamp,
        signature,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/openOrderList',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_open_orders_delete(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApiV3OpenOrdersDelete200ResponseInner]:
        """Cancel all Open Orders on a Symbol (TRADE)

        Cancels all active orders on a symbol. This includes OCO orders.  Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_open_orders_delete_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3OpenOrdersDelete200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_open_orders_delete_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ApiV3OpenOrdersDelete200ResponseInner]]:
        """Cancel all Open Orders on a Symbol (TRADE)

        Cancels all active orders on a symbol. This includes OCO orders.  Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_open_orders_delete_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3OpenOrdersDelete200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_open_orders_delete_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel all Open Orders on a Symbol (TRADE)

        Cancels all active orders on a symbol. This includes OCO orders.  Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_open_orders_delete_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3OpenOrdersDelete200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_open_orders_delete_serialize(
        self,
        symbol,
        timestamp,
        signature,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v3/openOrders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_open_orders_get(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        symbol: Annotated[Optional[StrictStr], Field(description="Trading symbol, e.g. BNBUSDT")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[OrderDetails]:
        """Current Open Orders (USER_DATA)

        Get all open orders on a symbol. Careful when accessing this with no symbol.  Weight(IP): - `6` for a single symbol; - `80` when the symbol parameter is omitted;

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param symbol: Trading symbol, e.g. BNBUSDT
        :type symbol: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_open_orders_get_serialize(
            timestamp=timestamp,
            signature=signature,
            symbol=symbol,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OrderDetails]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_open_orders_get_with_http_info(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        symbol: Annotated[Optional[StrictStr], Field(description="Trading symbol, e.g. BNBUSDT")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[OrderDetails]]:
        """Current Open Orders (USER_DATA)

        Get all open orders on a symbol. Careful when accessing this with no symbol.  Weight(IP): - `6` for a single symbol; - `80` when the symbol parameter is omitted;

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param symbol: Trading symbol, e.g. BNBUSDT
        :type symbol: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_open_orders_get_serialize(
            timestamp=timestamp,
            signature=signature,
            symbol=symbol,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OrderDetails]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_open_orders_get_without_preload_content(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        symbol: Annotated[Optional[StrictStr], Field(description="Trading symbol, e.g. BNBUSDT")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Current Open Orders (USER_DATA)

        Get all open orders on a symbol. Careful when accessing this with no symbol.  Weight(IP): - `6` for a single symbol; - `80` when the symbol parameter is omitted;

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param symbol: Trading symbol, e.g. BNBUSDT
        :type symbol: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_open_orders_get_serialize(
            timestamp=timestamp,
            signature=signature,
            symbol=symbol,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OrderDetails]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_open_orders_get_serialize(
        self,
        timestamp,
        signature,
        symbol,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/openOrders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_order_cancel_replace_post(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        type: Annotated[StrictStr, Field(description="Order type")],
        cancel_replace_mode: Annotated[StrictStr, Field(description="- `STOP_ON_FAILURE` If the cancel request fails, the new order placement will not be attempted. - `ALLOW_FAILURES` If new order placement will be attempted even if cancel request fails.")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        cancel_restrictions: Optional[StrictStr] = None,
        time_in_force: Annotated[Optional[StrictStr], Field(description="Order time in force")] = None,
        quantity: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order quantity")] = None,
        quote_order_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Quote quantity")] = None,
        price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order price")] = None,
        cancel_new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        cancel_orig_client_order_id: Annotated[Optional[StrictStr], Field(description="Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.")] = None,
        cancel_order_id: Annotated[Optional[StrictInt], Field(description="Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        trailing_delta: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        iceberg_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.")] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.")] = None,
        self_trade_prevention_mode: Annotated[Optional[StrictStr], Field(description="The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiV3OrderCancelReplacePost200Response:
        """Cancel an Existing Order and Send a New Order (Trade)

        Cancels an existing order and places a new order on the same symbol.  Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.  A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED), will still increase the order count by 1.  Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param type: Order type (required)
        :type type: str
        :param cancel_replace_mode: - `STOP_ON_FAILURE` If the cancel request fails, the new order placement will not be attempted. - `ALLOW_FAILURES` If new order placement will be attempted even if cancel request fails. (required)
        :type cancel_replace_mode: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param cancel_restrictions:
        :type cancel_restrictions: str
        :param time_in_force: Order time in force
        :type time_in_force: str
        :param quantity: Order quantity
        :type quantity: float
        :param quote_order_qty: Quote quantity
        :type quote_order_qty: float
        :param price: Order price
        :type price: float
        :param cancel_new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type cancel_new_client_order_id: str
        :param cancel_orig_client_order_id: Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
        :type cancel_orig_client_order_id: str
        :param cancel_order_id: Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
        :type cancel_order_id: int
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type: The value cannot be less than 1000000.
        :type strategy_type: int
        :param stop_price: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type stop_price: float
        :param trailing_delta: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type trailing_delta: float
        :param iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :type iceberg_qty: float
        :param new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :type new_order_resp_type: str
        :param self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :type self_trade_prevention_mode: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_cancel_replace_post_serialize(
            symbol=symbol,
            side=side,
            type=type,
            cancel_replace_mode=cancel_replace_mode,
            timestamp=timestamp,
            signature=signature,
            cancel_restrictions=cancel_restrictions,
            time_in_force=time_in_force,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            price=price,
            cancel_new_client_order_id=cancel_new_client_order_id,
            cancel_orig_client_order_id=cancel_orig_client_order_id,
            cancel_order_id=cancel_order_id,
            new_client_order_id=new_client_order_id,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            stop_price=stop_price,
            trailing_delta=trailing_delta,
            iceberg_qty=iceberg_qty,
            new_order_resp_type=new_order_resp_type,
            self_trade_prevention_mode=self_trade_prevention_mode,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3OrderCancelReplacePost200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_order_cancel_replace_post_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        type: Annotated[StrictStr, Field(description="Order type")],
        cancel_replace_mode: Annotated[StrictStr, Field(description="- `STOP_ON_FAILURE` If the cancel request fails, the new order placement will not be attempted. - `ALLOW_FAILURES` If new order placement will be attempted even if cancel request fails.")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        cancel_restrictions: Optional[StrictStr] = None,
        time_in_force: Annotated[Optional[StrictStr], Field(description="Order time in force")] = None,
        quantity: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order quantity")] = None,
        quote_order_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Quote quantity")] = None,
        price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order price")] = None,
        cancel_new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        cancel_orig_client_order_id: Annotated[Optional[StrictStr], Field(description="Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.")] = None,
        cancel_order_id: Annotated[Optional[StrictInt], Field(description="Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        trailing_delta: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        iceberg_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.")] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.")] = None,
        self_trade_prevention_mode: Annotated[Optional[StrictStr], Field(description="The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApiV3OrderCancelReplacePost200Response]:
        """Cancel an Existing Order and Send a New Order (Trade)

        Cancels an existing order and places a new order on the same symbol.  Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.  A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED), will still increase the order count by 1.  Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param type: Order type (required)
        :type type: str
        :param cancel_replace_mode: - `STOP_ON_FAILURE` If the cancel request fails, the new order placement will not be attempted. - `ALLOW_FAILURES` If new order placement will be attempted even if cancel request fails. (required)
        :type cancel_replace_mode: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param cancel_restrictions:
        :type cancel_restrictions: str
        :param time_in_force: Order time in force
        :type time_in_force: str
        :param quantity: Order quantity
        :type quantity: float
        :param quote_order_qty: Quote quantity
        :type quote_order_qty: float
        :param price: Order price
        :type price: float
        :param cancel_new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type cancel_new_client_order_id: str
        :param cancel_orig_client_order_id: Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
        :type cancel_orig_client_order_id: str
        :param cancel_order_id: Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
        :type cancel_order_id: int
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type: The value cannot be less than 1000000.
        :type strategy_type: int
        :param stop_price: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type stop_price: float
        :param trailing_delta: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type trailing_delta: float
        :param iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :type iceberg_qty: float
        :param new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :type new_order_resp_type: str
        :param self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :type self_trade_prevention_mode: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_cancel_replace_post_serialize(
            symbol=symbol,
            side=side,
            type=type,
            cancel_replace_mode=cancel_replace_mode,
            timestamp=timestamp,
            signature=signature,
            cancel_restrictions=cancel_restrictions,
            time_in_force=time_in_force,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            price=price,
            cancel_new_client_order_id=cancel_new_client_order_id,
            cancel_orig_client_order_id=cancel_orig_client_order_id,
            cancel_order_id=cancel_order_id,
            new_client_order_id=new_client_order_id,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            stop_price=stop_price,
            trailing_delta=trailing_delta,
            iceberg_qty=iceberg_qty,
            new_order_resp_type=new_order_resp_type,
            self_trade_prevention_mode=self_trade_prevention_mode,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3OrderCancelReplacePost200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_order_cancel_replace_post_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        type: Annotated[StrictStr, Field(description="Order type")],
        cancel_replace_mode: Annotated[StrictStr, Field(description="- `STOP_ON_FAILURE` If the cancel request fails, the new order placement will not be attempted. - `ALLOW_FAILURES` If new order placement will be attempted even if cancel request fails.")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        cancel_restrictions: Optional[StrictStr] = None,
        time_in_force: Annotated[Optional[StrictStr], Field(description="Order time in force")] = None,
        quantity: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order quantity")] = None,
        quote_order_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Quote quantity")] = None,
        price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order price")] = None,
        cancel_new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        cancel_orig_client_order_id: Annotated[Optional[StrictStr], Field(description="Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.")] = None,
        cancel_order_id: Annotated[Optional[StrictInt], Field(description="Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        trailing_delta: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        iceberg_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.")] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.")] = None,
        self_trade_prevention_mode: Annotated[Optional[StrictStr], Field(description="The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel an Existing Order and Send a New Order (Trade)

        Cancels an existing order and places a new order on the same symbol.  Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.  A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED), will still increase the order count by 1.  Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param type: Order type (required)
        :type type: str
        :param cancel_replace_mode: - `STOP_ON_FAILURE` If the cancel request fails, the new order placement will not be attempted. - `ALLOW_FAILURES` If new order placement will be attempted even if cancel request fails. (required)
        :type cancel_replace_mode: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param cancel_restrictions:
        :type cancel_restrictions: str
        :param time_in_force: Order time in force
        :type time_in_force: str
        :param quantity: Order quantity
        :type quantity: float
        :param quote_order_qty: Quote quantity
        :type quote_order_qty: float
        :param price: Order price
        :type price: float
        :param cancel_new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type cancel_new_client_order_id: str
        :param cancel_orig_client_order_id: Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
        :type cancel_orig_client_order_id: str
        :param cancel_order_id: Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
        :type cancel_order_id: int
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type: The value cannot be less than 1000000.
        :type strategy_type: int
        :param stop_price: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type stop_price: float
        :param trailing_delta: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type trailing_delta: float
        :param iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :type iceberg_qty: float
        :param new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :type new_order_resp_type: str
        :param self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :type self_trade_prevention_mode: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_cancel_replace_post_serialize(
            symbol=symbol,
            side=side,
            type=type,
            cancel_replace_mode=cancel_replace_mode,
            timestamp=timestamp,
            signature=signature,
            cancel_restrictions=cancel_restrictions,
            time_in_force=time_in_force,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            price=price,
            cancel_new_client_order_id=cancel_new_client_order_id,
            cancel_orig_client_order_id=cancel_orig_client_order_id,
            cancel_order_id=cancel_order_id,
            new_client_order_id=new_client_order_id,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            stop_price=stop_price,
            trailing_delta=trailing_delta,
            iceberg_qty=iceberg_qty,
            new_order_resp_type=new_order_resp_type,
            self_trade_prevention_mode=self_trade_prevention_mode,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3OrderCancelReplacePost200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_order_cancel_replace_post_serialize(
        self,
        symbol,
        side,
        type,
        cancel_replace_mode,
        timestamp,
        signature,
        cancel_restrictions,
        time_in_force,
        quantity,
        quote_order_qty,
        price,
        cancel_new_client_order_id,
        cancel_orig_client_order_id,
        cancel_order_id,
        new_client_order_id,
        strategy_id,
        strategy_type,
        stop_price,
        trailing_delta,
        iceberg_qty,
        new_order_resp_type,
        self_trade_prevention_mode,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if side is not None:
            
            _query_params.append(('side', side))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if cancel_replace_mode is not None:
            
            _query_params.append(('cancelReplaceMode', cancel_replace_mode))
            
        if cancel_restrictions is not None:
            
            _query_params.append(('cancelRestrictions', cancel_restrictions))
            
        if time_in_force is not None:
            
            _query_params.append(('timeInForce', time_in_force))
            
        if quantity is not None:
            
            _query_params.append(('quantity', quantity))
            
        if quote_order_qty is not None:
            
            _query_params.append(('quoteOrderQty', quote_order_qty))
            
        if price is not None:
            
            _query_params.append(('price', price))
            
        if cancel_new_client_order_id is not None:
            
            _query_params.append(('cancelNewClientOrderId', cancel_new_client_order_id))
            
        if cancel_orig_client_order_id is not None:
            
            _query_params.append(('cancelOrigClientOrderId', cancel_orig_client_order_id))
            
        if cancel_order_id is not None:
            
            _query_params.append(('cancelOrderId', cancel_order_id))
            
        if new_client_order_id is not None:
            
            _query_params.append(('newClientOrderId', new_client_order_id))
            
        if strategy_id is not None:
            
            _query_params.append(('strategyId', strategy_id))
            
        if strategy_type is not None:
            
            _query_params.append(('strategyType', strategy_type))
            
        if stop_price is not None:
            
            _query_params.append(('stopPrice', stop_price))
            
        if trailing_delta is not None:
            
            _query_params.append(('trailingDelta', trailing_delta))
            
        if iceberg_qty is not None:
            
            _query_params.append(('icebergQty', iceberg_qty))
            
        if new_order_resp_type is not None:
            
            _query_params.append(('newOrderRespType', new_order_resp_type))
            
        if self_trade_prevention_mode is not None:
            
            _query_params.append(('selfTradePreventionMode', self_trade_prevention_mode))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/order/cancelReplace',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_order_delete(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_id: Annotated[Optional[StrictInt], Field(description="Order id")] = None,
        orig_client_order_id: Annotated[Optional[StrictStr], Field(description="Order id from client")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        cancel_restrictions: Optional[StrictStr] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Order:
        """Cancel Order (TRADE)

        Cancel an active order.  Either `orderId` or `origClientOrderId` must be sent.  Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_id: Order id
        :type order_id: int
        :param orig_client_order_id: Order id from client
        :type orig_client_order_id: str
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param cancel_restrictions:
        :type cancel_restrictions: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_delete_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            order_id=order_id,
            orig_client_order_id=orig_client_order_id,
            new_client_order_id=new_client_order_id,
            cancel_restrictions=cancel_restrictions,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Order",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_order_delete_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_id: Annotated[Optional[StrictInt], Field(description="Order id")] = None,
        orig_client_order_id: Annotated[Optional[StrictStr], Field(description="Order id from client")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        cancel_restrictions: Optional[StrictStr] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Order]:
        """Cancel Order (TRADE)

        Cancel an active order.  Either `orderId` or `origClientOrderId` must be sent.  Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_id: Order id
        :type order_id: int
        :param orig_client_order_id: Order id from client
        :type orig_client_order_id: str
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param cancel_restrictions:
        :type cancel_restrictions: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_delete_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            order_id=order_id,
            orig_client_order_id=orig_client_order_id,
            new_client_order_id=new_client_order_id,
            cancel_restrictions=cancel_restrictions,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Order",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_order_delete_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_id: Annotated[Optional[StrictInt], Field(description="Order id")] = None,
        orig_client_order_id: Annotated[Optional[StrictStr], Field(description="Order id from client")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        cancel_restrictions: Optional[StrictStr] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel Order (TRADE)

        Cancel an active order.  Either `orderId` or `origClientOrderId` must be sent.  Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_id: Order id
        :type order_id: int
        :param orig_client_order_id: Order id from client
        :type orig_client_order_id: str
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param cancel_restrictions:
        :type cancel_restrictions: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_delete_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            order_id=order_id,
            orig_client_order_id=orig_client_order_id,
            new_client_order_id=new_client_order_id,
            cancel_restrictions=cancel_restrictions,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Order",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_order_delete_serialize(
        self,
        symbol,
        timestamp,
        signature,
        order_id,
        orig_client_order_id,
        new_client_order_id,
        cancel_restrictions,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        if orig_client_order_id is not None:
            
            _query_params.append(('origClientOrderId', orig_client_order_id))
            
        if new_client_order_id is not None:
            
            _query_params.append(('newClientOrderId', new_client_order_id))
            
        if cancel_restrictions is not None:
            
            _query_params.append(('cancelRestrictions', cancel_restrictions))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v3/order',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_order_get(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_id: Annotated[Optional[StrictInt], Field(description="Order id")] = None,
        orig_client_order_id: Annotated[Optional[StrictStr], Field(description="Order id from client")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OrderDetails:
        """Query Order (USER_DATA)

        Check an order's status.  - Either `orderId` or `origClientOrderId` must be sent. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 4

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_id: Order id
        :type order_id: int
        :param orig_client_order_id: Order id from client
        :type orig_client_order_id: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            order_id=order_id,
            orig_client_order_id=orig_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderDetails",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_order_get_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_id: Annotated[Optional[StrictInt], Field(description="Order id")] = None,
        orig_client_order_id: Annotated[Optional[StrictStr], Field(description="Order id from client")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OrderDetails]:
        """Query Order (USER_DATA)

        Check an order's status.  - Either `orderId` or `origClientOrderId` must be sent. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 4

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_id: Order id
        :type order_id: int
        :param orig_client_order_id: Order id from client
        :type orig_client_order_id: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            order_id=order_id,
            orig_client_order_id=orig_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderDetails",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_order_get_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_id: Annotated[Optional[StrictInt], Field(description="Order id")] = None,
        orig_client_order_id: Annotated[Optional[StrictStr], Field(description="Order id from client")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Order (USER_DATA)

        Check an order's status.  - Either `orderId` or `origClientOrderId` must be sent. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 4

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_id: Order id
        :type order_id: int
        :param orig_client_order_id: Order id from client
        :type orig_client_order_id: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_get_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            order_id=order_id,
            orig_client_order_id=orig_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderDetails",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_order_get_serialize(
        self,
        symbol,
        timestamp,
        signature,
        order_id,
        orig_client_order_id,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        if orig_client_order_id is not None:
            
            _query_params.append(('origClientOrderId', orig_client_order_id))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/order',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_order_list_delete(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_list_id: Annotated[Optional[StrictInt], Field(description="Order list id")] = None,
        list_client_order_id: Annotated[Optional[StrictStr], Field(description="A unique Id for the entire orderList")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OcoOrder:
        """Cancel OCO (TRADE)

        Cancel an entire Order List  Canceling an individual leg will cancel the entire OCO  Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_list_id: Order list id
        :type order_list_id: int
        :param list_client_order_id: A unique Id for the entire orderList
        :type list_client_order_id: str
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_list_delete_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            order_list_id=order_list_id,
            list_client_order_id=list_client_order_id,
            new_client_order_id=new_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OcoOrder",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_order_list_delete_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_list_id: Annotated[Optional[StrictInt], Field(description="Order list id")] = None,
        list_client_order_id: Annotated[Optional[StrictStr], Field(description="A unique Id for the entire orderList")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OcoOrder]:
        """Cancel OCO (TRADE)

        Cancel an entire Order List  Canceling an individual leg will cancel the entire OCO  Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_list_id: Order list id
        :type order_list_id: int
        :param list_client_order_id: A unique Id for the entire orderList
        :type list_client_order_id: str
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_list_delete_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            order_list_id=order_list_id,
            list_client_order_id=list_client_order_id,
            new_client_order_id=new_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OcoOrder",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_order_list_delete_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_list_id: Annotated[Optional[StrictInt], Field(description="Order list id")] = None,
        list_client_order_id: Annotated[Optional[StrictStr], Field(description="A unique Id for the entire orderList")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel OCO (TRADE)

        Cancel an entire Order List  Canceling an individual leg will cancel the entire OCO  Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_list_id: Order list id
        :type order_list_id: int
        :param list_client_order_id: A unique Id for the entire orderList
        :type list_client_order_id: str
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_list_delete_serialize(
            symbol=symbol,
            timestamp=timestamp,
            signature=signature,
            order_list_id=order_list_id,
            list_client_order_id=list_client_order_id,
            new_client_order_id=new_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OcoOrder",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_order_list_delete_serialize(
        self,
        symbol,
        timestamp,
        signature,
        order_list_id,
        list_client_order_id,
        new_client_order_id,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if order_list_id is not None:
            
            _query_params.append(('orderListId', order_list_id))
            
        if list_client_order_id is not None:
            
            _query_params.append(('listClientOrderId', list_client_order_id))
            
        if new_client_order_id is not None:
            
            _query_params.append(('newClientOrderId', new_client_order_id))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v3/orderList',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_order_list_get(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_list_id: Annotated[Optional[StrictInt], Field(description="Order list id")] = None,
        orig_client_order_id: Annotated[Optional[StrictStr], Field(description="Order id from client")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiV3OrderListGet200Response:
        """Query OCO (USER_DATA)

        Retrieves a specific OCO based on provided optional parameters  Weight(IP): 4

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_list_id: Order list id
        :type order_list_id: int
        :param orig_client_order_id: Order id from client
        :type orig_client_order_id: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_list_get_serialize(
            timestamp=timestamp,
            signature=signature,
            order_list_id=order_list_id,
            orig_client_order_id=orig_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3OrderListGet200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_order_list_get_with_http_info(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_list_id: Annotated[Optional[StrictInt], Field(description="Order list id")] = None,
        orig_client_order_id: Annotated[Optional[StrictStr], Field(description="Order id from client")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApiV3OrderListGet200Response]:
        """Query OCO (USER_DATA)

        Retrieves a specific OCO based on provided optional parameters  Weight(IP): 4

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_list_id: Order list id
        :type order_list_id: int
        :param orig_client_order_id: Order id from client
        :type orig_client_order_id: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_list_get_serialize(
            timestamp=timestamp,
            signature=signature,
            order_list_id=order_list_id,
            orig_client_order_id=orig_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3OrderListGet200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_order_list_get_without_preload_content(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        order_list_id: Annotated[Optional[StrictInt], Field(description="Order list id")] = None,
        orig_client_order_id: Annotated[Optional[StrictStr], Field(description="Order id from client")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query OCO (USER_DATA)

        Retrieves a specific OCO based on provided optional parameters  Weight(IP): 4

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param order_list_id: Order list id
        :type order_list_id: int
        :param orig_client_order_id: Order id from client
        :type orig_client_order_id: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_list_get_serialize(
            timestamp=timestamp,
            signature=signature,
            order_list_id=order_list_id,
            orig_client_order_id=orig_client_order_id,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3OrderListGet200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_order_list_get_serialize(
        self,
        timestamp,
        signature,
        order_list_id,
        orig_client_order_id,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if order_list_id is not None:
            
            _query_params.append(('orderListId', order_list_id))
            
        if orig_client_order_id is not None:
            
            _query_params.append(('origClientOrderId', orig_client_order_id))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/orderList',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_order_oco_post(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        quantity: Union[StrictFloat, StrictInt],
        price: Annotated[Union[StrictFloat, StrictInt], Field(description="Order price")],
        stop_price: Union[StrictFloat, StrictInt],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        list_client_order_id: Annotated[Optional[StrictStr], Field(description="A unique Id for the entire orderList")] = None,
        limit_client_order_id: Annotated[Optional[StrictStr], Field(description="A unique Id for the limit order")] = None,
        limit_strategy_id: Optional[StrictInt] = None,
        limit_strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        limit_iceberg_qty: Optional[Union[StrictFloat, StrictInt]] = None,
        trailing_delta: Optional[Union[StrictFloat, StrictInt]] = None,
        stop_client_order_id: Annotated[Optional[StrictStr], Field(description="A unique Id for the stop loss/stop loss limit leg")] = None,
        stop_strategy_id: Optional[StrictInt] = None,
        stop_strategy_type: Optional[StrictInt] = None,
        stop_limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="If provided, stopLimitTimeInForce is required.")] = None,
        stop_iceberg_qty: Optional[Union[StrictFloat, StrictInt]] = None,
        stop_limit_time_in_force: Optional[StrictStr] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON.")] = None,
        self_trade_prevention_mode: Annotated[Optional[StrictStr], Field(description="The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiV3OrderOcoPost200Response:
        """New OCO (TRADE)

        Send in a new OCO  - Price Restrictions:   - `SELL`: Limit Price > Last Price > Stop Price   - `BUY`: Limit Price < Last Price < Stop Price - Quantity Restrictions:     - Both legs must have the same quantity     - `ICEBERG` quantities however do not have to be the same - Order Rate Limit     - `OCO` counts as 2 orders against the order rate limit.  Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param quantity: (required)
        :type quantity: float
        :param price: Order price (required)
        :type price: float
        :param stop_price: (required)
        :type stop_price: float
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param list_client_order_id: A unique Id for the entire orderList
        :type list_client_order_id: str
        :param limit_client_order_id: A unique Id for the limit order
        :type limit_client_order_id: str
        :param limit_strategy_id:
        :type limit_strategy_id: int
        :param limit_strategy_type: The value cannot be less than 1000000.
        :type limit_strategy_type: int
        :param limit_iceberg_qty:
        :type limit_iceberg_qty: float
        :param trailing_delta:
        :type trailing_delta: float
        :param stop_client_order_id: A unique Id for the stop loss/stop loss limit leg
        :type stop_client_order_id: str
        :param stop_strategy_id:
        :type stop_strategy_id: int
        :param stop_strategy_type:
        :type stop_strategy_type: int
        :param stop_limit_price: If provided, stopLimitTimeInForce is required.
        :type stop_limit_price: float
        :param stop_iceberg_qty:
        :type stop_iceberg_qty: float
        :param stop_limit_time_in_force:
        :type stop_limit_time_in_force: str
        :param new_order_resp_type: Set the response JSON.
        :type new_order_resp_type: str
        :param self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :type self_trade_prevention_mode: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_oco_post_serialize(
            symbol=symbol,
            side=side,
            quantity=quantity,
            price=price,
            stop_price=stop_price,
            timestamp=timestamp,
            signature=signature,
            list_client_order_id=list_client_order_id,
            limit_client_order_id=limit_client_order_id,
            limit_strategy_id=limit_strategy_id,
            limit_strategy_type=limit_strategy_type,
            limit_iceberg_qty=limit_iceberg_qty,
            trailing_delta=trailing_delta,
            stop_client_order_id=stop_client_order_id,
            stop_strategy_id=stop_strategy_id,
            stop_strategy_type=stop_strategy_type,
            stop_limit_price=stop_limit_price,
            stop_iceberg_qty=stop_iceberg_qty,
            stop_limit_time_in_force=stop_limit_time_in_force,
            new_order_resp_type=new_order_resp_type,
            self_trade_prevention_mode=self_trade_prevention_mode,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3OrderOcoPost200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_order_oco_post_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        quantity: Union[StrictFloat, StrictInt],
        price: Annotated[Union[StrictFloat, StrictInt], Field(description="Order price")],
        stop_price: Union[StrictFloat, StrictInt],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        list_client_order_id: Annotated[Optional[StrictStr], Field(description="A unique Id for the entire orderList")] = None,
        limit_client_order_id: Annotated[Optional[StrictStr], Field(description="A unique Id for the limit order")] = None,
        limit_strategy_id: Optional[StrictInt] = None,
        limit_strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        limit_iceberg_qty: Optional[Union[StrictFloat, StrictInt]] = None,
        trailing_delta: Optional[Union[StrictFloat, StrictInt]] = None,
        stop_client_order_id: Annotated[Optional[StrictStr], Field(description="A unique Id for the stop loss/stop loss limit leg")] = None,
        stop_strategy_id: Optional[StrictInt] = None,
        stop_strategy_type: Optional[StrictInt] = None,
        stop_limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="If provided, stopLimitTimeInForce is required.")] = None,
        stop_iceberg_qty: Optional[Union[StrictFloat, StrictInt]] = None,
        stop_limit_time_in_force: Optional[StrictStr] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON.")] = None,
        self_trade_prevention_mode: Annotated[Optional[StrictStr], Field(description="The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApiV3OrderOcoPost200Response]:
        """New OCO (TRADE)

        Send in a new OCO  - Price Restrictions:   - `SELL`: Limit Price > Last Price > Stop Price   - `BUY`: Limit Price < Last Price < Stop Price - Quantity Restrictions:     - Both legs must have the same quantity     - `ICEBERG` quantities however do not have to be the same - Order Rate Limit     - `OCO` counts as 2 orders against the order rate limit.  Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param quantity: (required)
        :type quantity: float
        :param price: Order price (required)
        :type price: float
        :param stop_price: (required)
        :type stop_price: float
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param list_client_order_id: A unique Id for the entire orderList
        :type list_client_order_id: str
        :param limit_client_order_id: A unique Id for the limit order
        :type limit_client_order_id: str
        :param limit_strategy_id:
        :type limit_strategy_id: int
        :param limit_strategy_type: The value cannot be less than 1000000.
        :type limit_strategy_type: int
        :param limit_iceberg_qty:
        :type limit_iceberg_qty: float
        :param trailing_delta:
        :type trailing_delta: float
        :param stop_client_order_id: A unique Id for the stop loss/stop loss limit leg
        :type stop_client_order_id: str
        :param stop_strategy_id:
        :type stop_strategy_id: int
        :param stop_strategy_type:
        :type stop_strategy_type: int
        :param stop_limit_price: If provided, stopLimitTimeInForce is required.
        :type stop_limit_price: float
        :param stop_iceberg_qty:
        :type stop_iceberg_qty: float
        :param stop_limit_time_in_force:
        :type stop_limit_time_in_force: str
        :param new_order_resp_type: Set the response JSON.
        :type new_order_resp_type: str
        :param self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :type self_trade_prevention_mode: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_oco_post_serialize(
            symbol=symbol,
            side=side,
            quantity=quantity,
            price=price,
            stop_price=stop_price,
            timestamp=timestamp,
            signature=signature,
            list_client_order_id=list_client_order_id,
            limit_client_order_id=limit_client_order_id,
            limit_strategy_id=limit_strategy_id,
            limit_strategy_type=limit_strategy_type,
            limit_iceberg_qty=limit_iceberg_qty,
            trailing_delta=trailing_delta,
            stop_client_order_id=stop_client_order_id,
            stop_strategy_id=stop_strategy_id,
            stop_strategy_type=stop_strategy_type,
            stop_limit_price=stop_limit_price,
            stop_iceberg_qty=stop_iceberg_qty,
            stop_limit_time_in_force=stop_limit_time_in_force,
            new_order_resp_type=new_order_resp_type,
            self_trade_prevention_mode=self_trade_prevention_mode,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3OrderOcoPost200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_order_oco_post_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        quantity: Union[StrictFloat, StrictInt],
        price: Annotated[Union[StrictFloat, StrictInt], Field(description="Order price")],
        stop_price: Union[StrictFloat, StrictInt],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        list_client_order_id: Annotated[Optional[StrictStr], Field(description="A unique Id for the entire orderList")] = None,
        limit_client_order_id: Annotated[Optional[StrictStr], Field(description="A unique Id for the limit order")] = None,
        limit_strategy_id: Optional[StrictInt] = None,
        limit_strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        limit_iceberg_qty: Optional[Union[StrictFloat, StrictInt]] = None,
        trailing_delta: Optional[Union[StrictFloat, StrictInt]] = None,
        stop_client_order_id: Annotated[Optional[StrictStr], Field(description="A unique Id for the stop loss/stop loss limit leg")] = None,
        stop_strategy_id: Optional[StrictInt] = None,
        stop_strategy_type: Optional[StrictInt] = None,
        stop_limit_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="If provided, stopLimitTimeInForce is required.")] = None,
        stop_iceberg_qty: Optional[Union[StrictFloat, StrictInt]] = None,
        stop_limit_time_in_force: Optional[StrictStr] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON.")] = None,
        self_trade_prevention_mode: Annotated[Optional[StrictStr], Field(description="The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """New OCO (TRADE)

        Send in a new OCO  - Price Restrictions:   - `SELL`: Limit Price > Last Price > Stop Price   - `BUY`: Limit Price < Last Price < Stop Price - Quantity Restrictions:     - Both legs must have the same quantity     - `ICEBERG` quantities however do not have to be the same - Order Rate Limit     - `OCO` counts as 2 orders against the order rate limit.  Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param quantity: (required)
        :type quantity: float
        :param price: Order price (required)
        :type price: float
        :param stop_price: (required)
        :type stop_price: float
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param list_client_order_id: A unique Id for the entire orderList
        :type list_client_order_id: str
        :param limit_client_order_id: A unique Id for the limit order
        :type limit_client_order_id: str
        :param limit_strategy_id:
        :type limit_strategy_id: int
        :param limit_strategy_type: The value cannot be less than 1000000.
        :type limit_strategy_type: int
        :param limit_iceberg_qty:
        :type limit_iceberg_qty: float
        :param trailing_delta:
        :type trailing_delta: float
        :param stop_client_order_id: A unique Id for the stop loss/stop loss limit leg
        :type stop_client_order_id: str
        :param stop_strategy_id:
        :type stop_strategy_id: int
        :param stop_strategy_type:
        :type stop_strategy_type: int
        :param stop_limit_price: If provided, stopLimitTimeInForce is required.
        :type stop_limit_price: float
        :param stop_iceberg_qty:
        :type stop_iceberg_qty: float
        :param stop_limit_time_in_force:
        :type stop_limit_time_in_force: str
        :param new_order_resp_type: Set the response JSON.
        :type new_order_resp_type: str
        :param self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :type self_trade_prevention_mode: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_oco_post_serialize(
            symbol=symbol,
            side=side,
            quantity=quantity,
            price=price,
            stop_price=stop_price,
            timestamp=timestamp,
            signature=signature,
            list_client_order_id=list_client_order_id,
            limit_client_order_id=limit_client_order_id,
            limit_strategy_id=limit_strategy_id,
            limit_strategy_type=limit_strategy_type,
            limit_iceberg_qty=limit_iceberg_qty,
            trailing_delta=trailing_delta,
            stop_client_order_id=stop_client_order_id,
            stop_strategy_id=stop_strategy_id,
            stop_strategy_type=stop_strategy_type,
            stop_limit_price=stop_limit_price,
            stop_iceberg_qty=stop_iceberg_qty,
            stop_limit_time_in_force=stop_limit_time_in_force,
            new_order_resp_type=new_order_resp_type,
            self_trade_prevention_mode=self_trade_prevention_mode,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3OrderOcoPost200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_order_oco_post_serialize(
        self,
        symbol,
        side,
        quantity,
        price,
        stop_price,
        timestamp,
        signature,
        list_client_order_id,
        limit_client_order_id,
        limit_strategy_id,
        limit_strategy_type,
        limit_iceberg_qty,
        trailing_delta,
        stop_client_order_id,
        stop_strategy_id,
        stop_strategy_type,
        stop_limit_price,
        stop_iceberg_qty,
        stop_limit_time_in_force,
        new_order_resp_type,
        self_trade_prevention_mode,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if list_client_order_id is not None:
            
            _query_params.append(('listClientOrderId', list_client_order_id))
            
        if side is not None:
            
            _query_params.append(('side', side))
            
        if quantity is not None:
            
            _query_params.append(('quantity', quantity))
            
        if limit_client_order_id is not None:
            
            _query_params.append(('limitClientOrderId', limit_client_order_id))
            
        if limit_strategy_id is not None:
            
            _query_params.append(('limitStrategyId', limit_strategy_id))
            
        if limit_strategy_type is not None:
            
            _query_params.append(('limitStrategyType', limit_strategy_type))
            
        if price is not None:
            
            _query_params.append(('price', price))
            
        if limit_iceberg_qty is not None:
            
            _query_params.append(('limitIcebergQty', limit_iceberg_qty))
            
        if trailing_delta is not None:
            
            _query_params.append(('trailingDelta', trailing_delta))
            
        if stop_client_order_id is not None:
            
            _query_params.append(('stopClientOrderId', stop_client_order_id))
            
        if stop_price is not None:
            
            _query_params.append(('stopPrice', stop_price))
            
        if stop_strategy_id is not None:
            
            _query_params.append(('stopStrategyId', stop_strategy_id))
            
        if stop_strategy_type is not None:
            
            _query_params.append(('stopStrategyType', stop_strategy_type))
            
        if stop_limit_price is not None:
            
            _query_params.append(('stopLimitPrice', stop_limit_price))
            
        if stop_iceberg_qty is not None:
            
            _query_params.append(('stopIcebergQty', stop_iceberg_qty))
            
        if stop_limit_time_in_force is not None:
            
            _query_params.append(('stopLimitTimeInForce', stop_limit_time_in_force))
            
        if new_order_resp_type is not None:
            
            _query_params.append(('newOrderRespType', new_order_resp_type))
            
        if self_trade_prevention_mode is not None:
            
            _query_params.append(('selfTradePreventionMode', self_trade_prevention_mode))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/order/oco',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_order_post(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        type: Annotated[StrictStr, Field(description="Order type")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        time_in_force: Annotated[Optional[StrictStr], Field(description="Order time in force")] = None,
        quantity: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order quantity")] = None,
        quote_order_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Quote quantity")] = None,
        price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order price")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        trailing_delta: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        iceberg_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.")] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.")] = None,
        self_trade_prevention_mode: Annotated[Optional[StrictStr], Field(description="The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiV3OrderPost200Response:
        """New Order (TRADE)

        Send in a new order.  - `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker. - `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached. - Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`. - Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`. - `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price. - `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`. - `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`. - same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.  Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:  - Price above market price: `STOP_LOSS` `BUY`, `TAKE_PROFIT` `SELL` - Price below market price: `STOP_LOSS` `SELL`, `TAKE_PROFIT` `BUY`   Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param type: Order type (required)
        :type type: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param time_in_force: Order time in force
        :type time_in_force: str
        :param quantity: Order quantity
        :type quantity: float
        :param quote_order_qty: Quote quantity
        :type quote_order_qty: float
        :param price: Order price
        :type price: float
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type: The value cannot be less than 1000000.
        :type strategy_type: int
        :param stop_price: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type stop_price: float
        :param trailing_delta: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type trailing_delta: float
        :param iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :type iceberg_qty: float
        :param new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :type new_order_resp_type: str
        :param self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :type self_trade_prevention_mode: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_post_serialize(
            symbol=symbol,
            side=side,
            type=type,
            timestamp=timestamp,
            signature=signature,
            time_in_force=time_in_force,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            price=price,
            new_client_order_id=new_client_order_id,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            stop_price=stop_price,
            trailing_delta=trailing_delta,
            iceberg_qty=iceberg_qty,
            new_order_resp_type=new_order_resp_type,
            self_trade_prevention_mode=self_trade_prevention_mode,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3OrderPost200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_order_post_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        type: Annotated[StrictStr, Field(description="Order type")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        time_in_force: Annotated[Optional[StrictStr], Field(description="Order time in force")] = None,
        quantity: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order quantity")] = None,
        quote_order_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Quote quantity")] = None,
        price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order price")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        trailing_delta: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        iceberg_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.")] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.")] = None,
        self_trade_prevention_mode: Annotated[Optional[StrictStr], Field(description="The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApiV3OrderPost200Response]:
        """New Order (TRADE)

        Send in a new order.  - `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker. - `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached. - Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`. - Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`. - `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price. - `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`. - `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`. - same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.  Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:  - Price above market price: `STOP_LOSS` `BUY`, `TAKE_PROFIT` `SELL` - Price below market price: `STOP_LOSS` `SELL`, `TAKE_PROFIT` `BUY`   Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param type: Order type (required)
        :type type: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param time_in_force: Order time in force
        :type time_in_force: str
        :param quantity: Order quantity
        :type quantity: float
        :param quote_order_qty: Quote quantity
        :type quote_order_qty: float
        :param price: Order price
        :type price: float
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type: The value cannot be less than 1000000.
        :type strategy_type: int
        :param stop_price: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type stop_price: float
        :param trailing_delta: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type trailing_delta: float
        :param iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :type iceberg_qty: float
        :param new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :type new_order_resp_type: str
        :param self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :type self_trade_prevention_mode: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_post_serialize(
            symbol=symbol,
            side=side,
            type=type,
            timestamp=timestamp,
            signature=signature,
            time_in_force=time_in_force,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            price=price,
            new_client_order_id=new_client_order_id,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            stop_price=stop_price,
            trailing_delta=trailing_delta,
            iceberg_qty=iceberg_qty,
            new_order_resp_type=new_order_resp_type,
            self_trade_prevention_mode=self_trade_prevention_mode,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3OrderPost200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_order_post_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        type: Annotated[StrictStr, Field(description="Order type")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        time_in_force: Annotated[Optional[StrictStr], Field(description="Order time in force")] = None,
        quantity: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order quantity")] = None,
        quote_order_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Quote quantity")] = None,
        price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order price")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        trailing_delta: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        iceberg_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.")] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.")] = None,
        self_trade_prevention_mode: Annotated[Optional[StrictStr], Field(description="The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """New Order (TRADE)

        Send in a new order.  - `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker. - `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached. - Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`. - Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`. - `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price. - `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`. - `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`. - same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.  Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:  - Price above market price: `STOP_LOSS` `BUY`, `TAKE_PROFIT` `SELL` - Price below market price: `STOP_LOSS` `SELL`, `TAKE_PROFIT` `BUY`   Weight(IP): 1

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param type: Order type (required)
        :type type: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param time_in_force: Order time in force
        :type time_in_force: str
        :param quantity: Order quantity
        :type quantity: float
        :param quote_order_qty: Quote quantity
        :type quote_order_qty: float
        :param price: Order price
        :type price: float
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type: The value cannot be less than 1000000.
        :type strategy_type: int
        :param stop_price: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type stop_price: float
        :param trailing_delta: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type trailing_delta: float
        :param iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :type iceberg_qty: float
        :param new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :type new_order_resp_type: str
        :param self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :type self_trade_prevention_mode: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_post_serialize(
            symbol=symbol,
            side=side,
            type=type,
            timestamp=timestamp,
            signature=signature,
            time_in_force=time_in_force,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            price=price,
            new_client_order_id=new_client_order_id,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            stop_price=stop_price,
            trailing_delta=trailing_delta,
            iceberg_qty=iceberg_qty,
            new_order_resp_type=new_order_resp_type,
            self_trade_prevention_mode=self_trade_prevention_mode,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3OrderPost200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_order_post_serialize(
        self,
        symbol,
        side,
        type,
        timestamp,
        signature,
        time_in_force,
        quantity,
        quote_order_qty,
        price,
        new_client_order_id,
        strategy_id,
        strategy_type,
        stop_price,
        trailing_delta,
        iceberg_qty,
        new_order_resp_type,
        self_trade_prevention_mode,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if side is not None:
            
            _query_params.append(('side', side))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if time_in_force is not None:
            
            _query_params.append(('timeInForce', time_in_force))
            
        if quantity is not None:
            
            _query_params.append(('quantity', quantity))
            
        if quote_order_qty is not None:
            
            _query_params.append(('quoteOrderQty', quote_order_qty))
            
        if price is not None:
            
            _query_params.append(('price', price))
            
        if new_client_order_id is not None:
            
            _query_params.append(('newClientOrderId', new_client_order_id))
            
        if strategy_id is not None:
            
            _query_params.append(('strategyId', strategy_id))
            
        if strategy_type is not None:
            
            _query_params.append(('strategyType', strategy_type))
            
        if stop_price is not None:
            
            _query_params.append(('stopPrice', stop_price))
            
        if trailing_delta is not None:
            
            _query_params.append(('trailingDelta', trailing_delta))
            
        if iceberg_qty is not None:
            
            _query_params.append(('icebergQty', iceberg_qty))
            
        if new_order_resp_type is not None:
            
            _query_params.append(('newOrderRespType', new_order_resp_type))
            
        if self_trade_prevention_mode is not None:
            
            _query_params.append(('selfTradePreventionMode', self_trade_prevention_mode))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/order',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_order_test_post(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        type: Annotated[StrictStr, Field(description="Order type")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        time_in_force: Annotated[Optional[StrictStr], Field(description="Order time in force")] = None,
        quantity: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order quantity")] = None,
        quote_order_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Quote quantity")] = None,
        price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order price")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        trailing_delta: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        iceberg_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.")] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        compute_commission_rates: Annotated[Optional[StrictBool], Field(description="Default: false")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Test New Order (TRADE)

        Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.  Weight(IP):    - Without computeCommissionRates: `1`   - With computeCommissionRates: `20`

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param type: Order type (required)
        :type type: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param time_in_force: Order time in force
        :type time_in_force: str
        :param quantity: Order quantity
        :type quantity: float
        :param quote_order_qty: Quote quantity
        :type quote_order_qty: float
        :param price: Order price
        :type price: float
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type: The value cannot be less than 1000000.
        :type strategy_type: int
        :param stop_price: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type stop_price: float
        :param trailing_delta: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type trailing_delta: float
        :param iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :type iceberg_qty: float
        :param new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :type new_order_resp_type: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param compute_commission_rates: Default: false
        :type compute_commission_rates: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_test_post_serialize(
            symbol=symbol,
            side=side,
            type=type,
            timestamp=timestamp,
            signature=signature,
            time_in_force=time_in_force,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            price=price,
            new_client_order_id=new_client_order_id,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            stop_price=stop_price,
            trailing_delta=trailing_delta,
            iceberg_qty=iceberg_qty,
            new_order_resp_type=new_order_resp_type,
            recv_window=recv_window,
            compute_commission_rates=compute_commission_rates,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_order_test_post_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        type: Annotated[StrictStr, Field(description="Order type")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        time_in_force: Annotated[Optional[StrictStr], Field(description="Order time in force")] = None,
        quantity: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order quantity")] = None,
        quote_order_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Quote quantity")] = None,
        price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order price")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        trailing_delta: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        iceberg_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.")] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        compute_commission_rates: Annotated[Optional[StrictBool], Field(description="Default: false")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Test New Order (TRADE)

        Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.  Weight(IP):    - Without computeCommissionRates: `1`   - With computeCommissionRates: `20`

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param type: Order type (required)
        :type type: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param time_in_force: Order time in force
        :type time_in_force: str
        :param quantity: Order quantity
        :type quantity: float
        :param quote_order_qty: Quote quantity
        :type quote_order_qty: float
        :param price: Order price
        :type price: float
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type: The value cannot be less than 1000000.
        :type strategy_type: int
        :param stop_price: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type stop_price: float
        :param trailing_delta: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type trailing_delta: float
        :param iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :type iceberg_qty: float
        :param new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :type new_order_resp_type: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param compute_commission_rates: Default: false
        :type compute_commission_rates: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_test_post_serialize(
            symbol=symbol,
            side=side,
            type=type,
            timestamp=timestamp,
            signature=signature,
            time_in_force=time_in_force,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            price=price,
            new_client_order_id=new_client_order_id,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            stop_price=stop_price,
            trailing_delta=trailing_delta,
            iceberg_qty=iceberg_qty,
            new_order_resp_type=new_order_resp_type,
            recv_window=recv_window,
            compute_commission_rates=compute_commission_rates,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_order_test_post_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        type: Annotated[StrictStr, Field(description="Order type")],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        time_in_force: Annotated[Optional[StrictStr], Field(description="Order time in force")] = None,
        quantity: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order quantity")] = None,
        quote_order_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Quote quantity")] = None,
        price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Order price")] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        stop_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        trailing_delta: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.")] = None,
        iceberg_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.")] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        compute_commission_rates: Annotated[Optional[StrictBool], Field(description="Default: false")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Test New Order (TRADE)

        Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.  Weight(IP):    - Without computeCommissionRates: `1`   - With computeCommissionRates: `20`

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param type: Order type (required)
        :type type: str
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param time_in_force: Order time in force
        :type time_in_force: str
        :param quantity: Order quantity
        :type quantity: float
        :param quote_order_qty: Quote quantity
        :type quote_order_qty: float
        :param price: Order price
        :type price: float
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type: The value cannot be less than 1000000.
        :type strategy_type: int
        :param stop_price: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type stop_price: float
        :param trailing_delta: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :type trailing_delta: float
        :param iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :type iceberg_qty: float
        :param new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :type new_order_resp_type: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param compute_commission_rates: Default: false
        :type compute_commission_rates: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_order_test_post_serialize(
            symbol=symbol,
            side=side,
            type=type,
            timestamp=timestamp,
            signature=signature,
            time_in_force=time_in_force,
            quantity=quantity,
            quote_order_qty=quote_order_qty,
            price=price,
            new_client_order_id=new_client_order_id,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            stop_price=stop_price,
            trailing_delta=trailing_delta,
            iceberg_qty=iceberg_qty,
            new_order_resp_type=new_order_resp_type,
            recv_window=recv_window,
            compute_commission_rates=compute_commission_rates,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_order_test_post_serialize(
        self,
        symbol,
        side,
        type,
        timestamp,
        signature,
        time_in_force,
        quantity,
        quote_order_qty,
        price,
        new_client_order_id,
        strategy_id,
        strategy_type,
        stop_price,
        trailing_delta,
        iceberg_qty,
        new_order_resp_type,
        recv_window,
        compute_commission_rates,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if side is not None:
            
            _query_params.append(('side', side))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if time_in_force is not None:
            
            _query_params.append(('timeInForce', time_in_force))
            
        if quantity is not None:
            
            _query_params.append(('quantity', quantity))
            
        if quote_order_qty is not None:
            
            _query_params.append(('quoteOrderQty', quote_order_qty))
            
        if price is not None:
            
            _query_params.append(('price', price))
            
        if new_client_order_id is not None:
            
            _query_params.append(('newClientOrderId', new_client_order_id))
            
        if strategy_id is not None:
            
            _query_params.append(('strategyId', strategy_id))
            
        if strategy_type is not None:
            
            _query_params.append(('strategyType', strategy_type))
            
        if stop_price is not None:
            
            _query_params.append(('stopPrice', stop_price))
            
        if trailing_delta is not None:
            
            _query_params.append(('trailingDelta', trailing_delta))
            
        if iceberg_qty is not None:
            
            _query_params.append(('icebergQty', iceberg_qty))
            
        if new_order_resp_type is not None:
            
            _query_params.append(('newOrderRespType', new_order_resp_type))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if compute_commission_rates is not None:
            
            _query_params.append(('computeCommissionRates', compute_commission_rates))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/order/test',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_rate_limit_order_get(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApiV3RateLimitOrderGet200ResponseInner]:
        """Query Current Order Count Usage (TRADE)

        Displays the user's current order count usage for all intervals.  Weight(IP): 40

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_rate_limit_order_get_serialize(
            timestamp=timestamp,
            signature=signature,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3RateLimitOrderGet200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_rate_limit_order_get_with_http_info(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ApiV3RateLimitOrderGet200ResponseInner]]:
        """Query Current Order Count Usage (TRADE)

        Displays the user's current order count usage for all intervals.  Weight(IP): 40

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_rate_limit_order_get_serialize(
            timestamp=timestamp,
            signature=signature,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3RateLimitOrderGet200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_rate_limit_order_get_without_preload_content(
        self,
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Current Order Count Usage (TRADE)

        Displays the user's current order count usage for all intervals.  Weight(IP): 40

        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_rate_limit_order_get_serialize(
            timestamp=timestamp,
            signature=signature,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApiV3RateLimitOrderGet200ResponseInner]",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_rate_limit_order_get_serialize(
        self,
        timestamp,
        signature,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/rateLimit/order',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_sor_order_post(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        type: Annotated[StrictStr, Field(description="Order type")],
        quantity: Union[StrictFloat, StrictInt],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        time_in_force: Annotated[Optional[StrictStr], Field(description="Order time in force")] = None,
        price: Optional[Union[StrictFloat, StrictInt]] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        iceberg_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.")] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.")] = None,
        self_trade_prevention_mode: Annotated[Optional[StrictStr], Field(description="The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiV3SorOrderPost200Response:
        """New order using SOR (TRADE)

        Weight(IP): 6

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param type: Order type (required)
        :type type: str
        :param quantity: (required)
        :type quantity: float
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param time_in_force: Order time in force
        :type time_in_force: str
        :param price:
        :type price: float
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type: The value cannot be less than 1000000.
        :type strategy_type: int
        :param iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :type iceberg_qty: float
        :param new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :type new_order_resp_type: str
        :param self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :type self_trade_prevention_mode: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_sor_order_post_serialize(
            symbol=symbol,
            side=side,
            type=type,
            quantity=quantity,
            timestamp=timestamp,
            signature=signature,
            time_in_force=time_in_force,
            price=price,
            new_client_order_id=new_client_order_id,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            iceberg_qty=iceberg_qty,
            new_order_resp_type=new_order_resp_type,
            self_trade_prevention_mode=self_trade_prevention_mode,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3SorOrderPost200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_sor_order_post_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        type: Annotated[StrictStr, Field(description="Order type")],
        quantity: Union[StrictFloat, StrictInt],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        time_in_force: Annotated[Optional[StrictStr], Field(description="Order time in force")] = None,
        price: Optional[Union[StrictFloat, StrictInt]] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        iceberg_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.")] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.")] = None,
        self_trade_prevention_mode: Annotated[Optional[StrictStr], Field(description="The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApiV3SorOrderPost200Response]:
        """New order using SOR (TRADE)

        Weight(IP): 6

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param type: Order type (required)
        :type type: str
        :param quantity: (required)
        :type quantity: float
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param time_in_force: Order time in force
        :type time_in_force: str
        :param price:
        :type price: float
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type: The value cannot be less than 1000000.
        :type strategy_type: int
        :param iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :type iceberg_qty: float
        :param new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :type new_order_resp_type: str
        :param self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :type self_trade_prevention_mode: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_sor_order_post_serialize(
            symbol=symbol,
            side=side,
            type=type,
            quantity=quantity,
            timestamp=timestamp,
            signature=signature,
            time_in_force=time_in_force,
            price=price,
            new_client_order_id=new_client_order_id,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            iceberg_qty=iceberg_qty,
            new_order_resp_type=new_order_resp_type,
            self_trade_prevention_mode=self_trade_prevention_mode,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3SorOrderPost200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_sor_order_post_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        type: Annotated[StrictStr, Field(description="Order type")],
        quantity: Union[StrictFloat, StrictInt],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        time_in_force: Annotated[Optional[StrictStr], Field(description="Order time in force")] = None,
        price: Optional[Union[StrictFloat, StrictInt]] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        iceberg_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.")] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.")] = None,
        self_trade_prevention_mode: Annotated[Optional[StrictStr], Field(description="The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """New order using SOR (TRADE)

        Weight(IP): 6

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param type: Order type (required)
        :type type: str
        :param quantity: (required)
        :type quantity: float
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param time_in_force: Order time in force
        :type time_in_force: str
        :param price:
        :type price: float
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type: The value cannot be less than 1000000.
        :type strategy_type: int
        :param iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :type iceberg_qty: float
        :param new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :type new_order_resp_type: str
        :param self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :type self_trade_prevention_mode: str
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_sor_order_post_serialize(
            symbol=symbol,
            side=side,
            type=type,
            quantity=quantity,
            timestamp=timestamp,
            signature=signature,
            time_in_force=time_in_force,
            price=price,
            new_client_order_id=new_client_order_id,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            iceberg_qty=iceberg_qty,
            new_order_resp_type=new_order_resp_type,
            self_trade_prevention_mode=self_trade_prevention_mode,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiV3SorOrderPost200Response",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_sor_order_post_serialize(
        self,
        symbol,
        side,
        type,
        quantity,
        timestamp,
        signature,
        time_in_force,
        price,
        new_client_order_id,
        strategy_id,
        strategy_type,
        iceberg_qty,
        new_order_resp_type,
        self_trade_prevention_mode,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if side is not None:
            
            _query_params.append(('side', side))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if time_in_force is not None:
            
            _query_params.append(('timeInForce', time_in_force))
            
        if quantity is not None:
            
            _query_params.append(('quantity', quantity))
            
        if price is not None:
            
            _query_params.append(('price', price))
            
        if new_client_order_id is not None:
            
            _query_params.append(('newClientOrderId', new_client_order_id))
            
        if strategy_id is not None:
            
            _query_params.append(('strategyId', strategy_id))
            
        if strategy_type is not None:
            
            _query_params.append(('strategyType', strategy_type))
            
        if iceberg_qty is not None:
            
            _query_params.append(('icebergQty', iceberg_qty))
            
        if new_order_resp_type is not None:
            
            _query_params.append(('newOrderRespType', new_order_resp_type))
            
        if self_trade_prevention_mode is not None:
            
            _query_params.append(('selfTradePreventionMode', self_trade_prevention_mode))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/sor/order',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_v3_sor_order_test_post(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        type: Annotated[StrictStr, Field(description="Order type")],
        quantity: Union[StrictFloat, StrictInt],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        time_in_force: Annotated[Optional[StrictStr], Field(description="Order time in force")] = None,
        price: Optional[Union[StrictFloat, StrictInt]] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        iceberg_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.")] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.")] = None,
        self_trade_prevention_mode: Annotated[Optional[StrictStr], Field(description="The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.")] = None,
        compute_commission_rates: Annotated[Optional[StrictBool], Field(description="Default: false")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Test new order using SOR (TRADE)

        Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.  Weight(IP):    - Without computeCommissionRates: `1`   - With computeCommissionRates: `20`

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param type: Order type (required)
        :type type: str
        :param quantity: (required)
        :type quantity: float
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param time_in_force: Order time in force
        :type time_in_force: str
        :param price:
        :type price: float
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type: The value cannot be less than 1000000.
        :type strategy_type: int
        :param iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :type iceberg_qty: float
        :param new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :type new_order_resp_type: str
        :param self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :type self_trade_prevention_mode: str
        :param compute_commission_rates: Default: false
        :type compute_commission_rates: bool
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_sor_order_test_post_serialize(
            symbol=symbol,
            side=side,
            type=type,
            quantity=quantity,
            timestamp=timestamp,
            signature=signature,
            time_in_force=time_in_force,
            price=price,
            new_client_order_id=new_client_order_id,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            iceberg_qty=iceberg_qty,
            new_order_resp_type=new_order_resp_type,
            self_trade_prevention_mode=self_trade_prevention_mode,
            compute_commission_rates=compute_commission_rates,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_v3_sor_order_test_post_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        type: Annotated[StrictStr, Field(description="Order type")],
        quantity: Union[StrictFloat, StrictInt],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        time_in_force: Annotated[Optional[StrictStr], Field(description="Order time in force")] = None,
        price: Optional[Union[StrictFloat, StrictInt]] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        iceberg_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.")] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.")] = None,
        self_trade_prevention_mode: Annotated[Optional[StrictStr], Field(description="The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.")] = None,
        compute_commission_rates: Annotated[Optional[StrictBool], Field(description="Default: false")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Test new order using SOR (TRADE)

        Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.  Weight(IP):    - Without computeCommissionRates: `1`   - With computeCommissionRates: `20`

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param type: Order type (required)
        :type type: str
        :param quantity: (required)
        :type quantity: float
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param time_in_force: Order time in force
        :type time_in_force: str
        :param price:
        :type price: float
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type: The value cannot be less than 1000000.
        :type strategy_type: int
        :param iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :type iceberg_qty: float
        :param new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :type new_order_resp_type: str
        :param self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :type self_trade_prevention_mode: str
        :param compute_commission_rates: Default: false
        :type compute_commission_rates: bool
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_sor_order_test_post_serialize(
            symbol=symbol,
            side=side,
            type=type,
            quantity=quantity,
            timestamp=timestamp,
            signature=signature,
            time_in_force=time_in_force,
            price=price,
            new_client_order_id=new_client_order_id,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            iceberg_qty=iceberg_qty,
            new_order_resp_type=new_order_resp_type,
            self_trade_prevention_mode=self_trade_prevention_mode,
            compute_commission_rates=compute_commission_rates,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_v3_sor_order_test_post_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Trading symbol, e.g. BNBUSDT")],
        side: StrictStr,
        type: Annotated[StrictStr, Field(description="Order type")],
        quantity: Union[StrictFloat, StrictInt],
        timestamp: Annotated[StrictInt, Field(description="UTC timestamp in ms")],
        signature: Annotated[StrictStr, Field(description="Signature")],
        time_in_force: Annotated[Optional[StrictStr], Field(description="Order time in force")] = None,
        price: Optional[Union[StrictFloat, StrictInt]] = None,
        new_client_order_id: Annotated[Optional[StrictStr], Field(description="Used to uniquely identify this cancel. Automatically generated by default")] = None,
        strategy_id: Optional[StrictInt] = None,
        strategy_type: Annotated[Optional[StrictInt], Field(description="The value cannot be less than 1000000.")] = None,
        iceberg_qty: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.")] = None,
        new_order_resp_type: Annotated[Optional[StrictStr], Field(description="Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.")] = None,
        self_trade_prevention_mode: Annotated[Optional[StrictStr], Field(description="The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.")] = None,
        compute_commission_rates: Annotated[Optional[StrictBool], Field(description="Default: false")] = None,
        recv_window: Annotated[Optional[StrictInt], Field(description="The value cannot be greater than 60000")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Test new order using SOR (TRADE)

        Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.  Weight(IP):    - Without computeCommissionRates: `1`   - With computeCommissionRates: `20`

        :param symbol: Trading symbol, e.g. BNBUSDT (required)
        :type symbol: str
        :param side: (required)
        :type side: str
        :param type: Order type (required)
        :type type: str
        :param quantity: (required)
        :type quantity: float
        :param timestamp: UTC timestamp in ms (required)
        :type timestamp: int
        :param signature: Signature (required)
        :type signature: str
        :param time_in_force: Order time in force
        :type time_in_force: str
        :param price:
        :type price: float
        :param new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :type new_client_order_id: str
        :param strategy_id:
        :type strategy_id: int
        :param strategy_type: The value cannot be less than 1000000.
        :type strategy_type: int
        :param iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :type iceberg_qty: float
        :param new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :type new_order_resp_type: str
        :param self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :type self_trade_prevention_mode: str
        :param compute_commission_rates: Default: false
        :type compute_commission_rates: bool
        :param recv_window: The value cannot be greater than 60000
        :type recv_window: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_v3_sor_order_test_post_serialize(
            symbol=symbol,
            side=side,
            type=type,
            quantity=quantity,
            timestamp=timestamp,
            signature=signature,
            time_in_force=time_in_force,
            price=price,
            new_client_order_id=new_client_order_id,
            strategy_id=strategy_id,
            strategy_type=strategy_type,
            iceberg_qty=iceberg_qty,
            new_order_resp_type=new_order_resp_type,
            self_trade_prevention_mode=self_trade_prevention_mode,
            compute_commission_rates=compute_commission_rates,
            recv_window=recv_window,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "Error",
            '401': "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_v3_sor_order_test_post_serialize(
        self,
        symbol,
        side,
        type,
        quantity,
        timestamp,
        signature,
        time_in_force,
        price,
        new_client_order_id,
        strategy_id,
        strategy_type,
        iceberg_qty,
        new_order_resp_type,
        self_trade_prevention_mode,
        compute_commission_rates,
        recv_window,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if side is not None:
            
            _query_params.append(('side', side))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if time_in_force is not None:
            
            _query_params.append(('timeInForce', time_in_force))
            
        if quantity is not None:
            
            _query_params.append(('quantity', quantity))
            
        if price is not None:
            
            _query_params.append(('price', price))
            
        if new_client_order_id is not None:
            
            _query_params.append(('newClientOrderId', new_client_order_id))
            
        if strategy_id is not None:
            
            _query_params.append(('strategyId', strategy_id))
            
        if strategy_type is not None:
            
            _query_params.append(('strategyType', strategy_type))
            
        if iceberg_qty is not None:
            
            _query_params.append(('icebergQty', iceberg_qty))
            
        if new_order_resp_type is not None:
            
            _query_params.append(('newOrderRespType', new_order_resp_type))
            
        if self_trade_prevention_mode is not None:
            
            _query_params.append(('selfTradePreventionMode', self_trade_prevention_mode))
            
        if compute_commission_rates is not None:
            
            _query_params.append(('computeCommissionRates', compute_commission_rates))
            
        if recv_window is not None:
            
            _query_params.append(('recvWindow', recv_window))
            
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if signature is not None:
            
            _query_params.append(('signature', signature))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/sor/order/test',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


