/*
 * Binance Public Spot API
 *
 * OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`api_v3_account_commission_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3AccountCommissionGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_account_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3AccountGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_all_order_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3AllOrderListGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_all_orders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3AllOrdersGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_my_allocations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3MyAllocationsGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_my_prevented_matches_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3MyPreventedMatchesGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_my_trades_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3MyTradesGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_open_order_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OpenOrderListGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_open_orders_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OpenOrdersDeleteError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_open_orders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OpenOrdersGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_cancel_replace_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderCancelReplacePostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderDeleteError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_list_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderListDeleteError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderListGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_oco_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderOcoPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_order_test_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3OrderTestPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_rate_limit_order_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3RateLimitOrderGetError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_sor_order_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3SorOrderPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v3_sor_order_test_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV3SorOrderTestPostError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}


/// Get current account commission rates.  Weight: 20
pub async fn api_v3_account_commission_get(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str) -> Result<models::ApiV3AccountCommissionGet200Response, Error<ApiV3AccountCommissionGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/account/commission", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("symbol", &symbol.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3AccountCommissionGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get current account information.  Weight(IP): 20
pub async fn api_v3_account_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<models::Account, Error<ApiV3AccountGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/account", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3AccountGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves all OCO based on provided optional parameters  Weight(IP): 20
pub async fn api_v3_all_order_list_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, from_id: Option<i64>, start_time: Option<i64>, end_time: Option<i64>, limit: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::ApiV3AllOrderListGet200ResponseInner>, Error<ApiV3AllOrderListGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/allOrderList", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = from_id {
        local_var_req_builder = local_var_req_builder.query(&[("fromId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_time {
        local_var_req_builder = local_var_req_builder.query(&[("startTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_time {
        local_var_req_builder = local_var_req_builder.query(&[("endTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3AllOrderListGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all account orders; active, canceled, or filled..  - If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time. - If `startTime` and/or `endTime` provided, `orderId` is not required  Weight(IP): 20
pub async fn api_v3_all_orders_get(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, order_id: Option<i64>, start_time: Option<i64>, end_time: Option<i64>, limit: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::OrderDetails>, Error<ApiV3AllOrdersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/allOrders", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("symbol", &symbol.to_string())]);
    if let Some(ref local_var_str) = order_id {
        local_var_req_builder = local_var_req_builder.query(&[("orderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_time {
        local_var_req_builder = local_var_req_builder.query(&[("startTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_time {
        local_var_req_builder = local_var_req_builder.query(&[("endTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3AllOrdersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves allocations resulting from SOR order placement.  Weight: 20  Supported parameter combinations: Parameters                             Response symbol                                 allocations from oldest to newest symbol + startTime                     oldest allocations since startTime symbol + endTime                       newest allocations until endTime symbol + startTime + endTime           allocations within the time range symbol + fromAllocationId             allocations by allocation ID symbol + orderId                       allocations related to an order starting with oldest symbol + orderId + fromAllocationId   allocations related to an order by allocation ID  Note: The time between startTime and endTime can't be longer than 24 hours.
pub async fn api_v3_my_allocations_get(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, start_time: Option<i64>, end_time: Option<i64>, from_allocation_id: Option<i64>, limit: Option<i32>, order_id: Option<i64>, recv_window: Option<i64>) -> Result<Vec<models::ApiV3MyAllocationsGet200ResponseInner>, Error<ApiV3MyAllocationsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/myAllocations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("symbol", &symbol.to_string())]);
    if let Some(ref local_var_str) = start_time {
        local_var_req_builder = local_var_req_builder.query(&[("startTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_time {
        local_var_req_builder = local_var_req_builder.query(&[("endTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from_allocation_id {
        local_var_req_builder = local_var_req_builder.query(&[("fromAllocationId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order_id {
        local_var_req_builder = local_var_req_builder.query(&[("orderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3MyAllocationsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Displays the list of orders that were expired because of STP.  For additional information on what a Prevented match is, as well as Self Trade Prevention (STP), please refer to our STP FAQ page.  These are the combinations supported:  * symbol + preventedMatchId * symbol + orderId * symbol + orderId + fromPreventedMatchId (limit will default to 500) * symbol + orderId + fromPreventedMatchId + limit  Weight(IP):  Case                             Weight If symbol is invalid:           2 Querying by preventedMatchId:   2 Querying by orderId:             20
pub async fn api_v3_my_prevented_matches_get(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, prevented_match_id: Option<i64>, order_id: Option<i64>, from_prevented_match_id: Option<i64>, limit: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::ApiV3MyPreventedMatchesGet200ResponseInner>, Error<ApiV3MyPreventedMatchesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/myPreventedMatches", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("symbol", &symbol.to_string())]);
    if let Some(ref local_var_str) = prevented_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("preventedMatchId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order_id {
        local_var_req_builder = local_var_req_builder.query(&[("orderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from_prevented_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("fromPreventedMatchId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3MyPreventedMatchesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get trades for a specific account and symbol.  If `fromId` is set, it will get id >= that `fromId`. Otherwise most recent orders are returned.  The time between startTime and endTime can't be longer than 24 hours. These are the supported combinations of all parameters:    symbol    symbol + orderId    symbol + startTime    symbol + endTime    symbol + fromId    symbol + startTime + endTime    symbol+ orderId + fromId  Weight(IP): 20
pub async fn api_v3_my_trades_get(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, order_id: Option<i64>, start_time: Option<i64>, end_time: Option<i64>, from_id: Option<i64>, limit: Option<i32>, recv_window: Option<i64>) -> Result<Vec<models::MyTrade>, Error<ApiV3MyTradesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/myTrades", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("symbol", &symbol.to_string())]);
    if let Some(ref local_var_str) = order_id {
        local_var_req_builder = local_var_req_builder.query(&[("orderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_time {
        local_var_req_builder = local_var_req_builder.query(&[("startTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_time {
        local_var_req_builder = local_var_req_builder.query(&[("endTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from_id {
        local_var_req_builder = local_var_req_builder.query(&[("fromId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3MyTradesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Weight(IP): 6
pub async fn api_v3_open_order_list_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<Vec<models::ApiV3OpenOrderListGet200ResponseInner>, Error<ApiV3OpenOrderListGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/openOrderList", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3OpenOrderListGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Cancels all active orders on a symbol. This includes OCO orders.  Weight(IP): 1
pub async fn api_v3_open_orders_delete(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<Vec<models::ApiV3OpenOrdersDelete200ResponseInner>, Error<ApiV3OpenOrdersDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/openOrders", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("symbol", &symbol.to_string())]);
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3OpenOrdersDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all open orders on a symbol. Careful when accessing this with no symbol.  Weight(IP): - `6` for a single symbol; - `80` when the symbol parameter is omitted;
pub async fn api_v3_open_orders_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, symbol: Option<&str>, recv_window: Option<i64>) -> Result<Vec<models::OrderDetails>, Error<ApiV3OpenOrdersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/openOrders", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = symbol {
        local_var_req_builder = local_var_req_builder.query(&[("symbol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3OpenOrdersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Cancels an existing order and places a new order on the same symbol.  Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.  A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED), will still increase the order count by 1.  Weight(IP): 1
pub async fn api_v3_order_cancel_replace_post(configuration: &configuration::Configuration, symbol: &str, side: &str, r#type: &str, cancel_replace_mode: &str, timestamp: i64, signature: &str, cancel_restrictions: Option<&str>, time_in_force: Option<&str>, quantity: Option<f64>, quote_order_qty: Option<f64>, price: Option<f64>, cancel_new_client_order_id: Option<&str>, cancel_orig_client_order_id: Option<&str>, cancel_order_id: Option<i64>, new_client_order_id: Option<&str>, strategy_id: Option<i64>, strategy_type: Option<i64>, stop_price: Option<f64>, trailing_delta: Option<f64>, iceberg_qty: Option<f64>, new_order_resp_type: Option<&str>, self_trade_prevention_mode: Option<&str>, recv_window: Option<i64>) -> Result<models::ApiV3OrderCancelReplacePost200Response, Error<ApiV3OrderCancelReplacePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/order/cancelReplace", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("symbol", &symbol.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("side", &side.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("type", &r#type.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("cancelReplaceMode", &cancel_replace_mode.to_string())]);
    if let Some(ref local_var_str) = cancel_restrictions {
        local_var_req_builder = local_var_req_builder.query(&[("cancelRestrictions", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time_in_force {
        local_var_req_builder = local_var_req_builder.query(&[("timeInForce", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quantity {
        local_var_req_builder = local_var_req_builder.query(&[("quantity", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quote_order_qty {
        local_var_req_builder = local_var_req_builder.query(&[("quoteOrderQty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = price {
        local_var_req_builder = local_var_req_builder.query(&[("price", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cancel_new_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("cancelNewClientOrderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cancel_orig_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("cancelOrigClientOrderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cancel_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("cancelOrderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("newClientOrderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = strategy_id {
        local_var_req_builder = local_var_req_builder.query(&[("strategyId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = strategy_type {
        local_var_req_builder = local_var_req_builder.query(&[("strategyType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stop_price {
        local_var_req_builder = local_var_req_builder.query(&[("stopPrice", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trailing_delta {
        local_var_req_builder = local_var_req_builder.query(&[("trailingDelta", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = iceberg_qty {
        local_var_req_builder = local_var_req_builder.query(&[("icebergQty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_order_resp_type {
        local_var_req_builder = local_var_req_builder.query(&[("newOrderRespType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = self_trade_prevention_mode {
        local_var_req_builder = local_var_req_builder.query(&[("selfTradePreventionMode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3OrderCancelReplacePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Cancel an active order.  Either `orderId` or `origClientOrderId` must be sent.  Weight(IP): 1
pub async fn api_v3_order_delete(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, order_id: Option<i64>, orig_client_order_id: Option<&str>, new_client_order_id: Option<&str>, cancel_restrictions: Option<&str>, recv_window: Option<i64>) -> Result<models::Order, Error<ApiV3OrderDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/order", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("symbol", &symbol.to_string())]);
    if let Some(ref local_var_str) = order_id {
        local_var_req_builder = local_var_req_builder.query(&[("orderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = orig_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("origClientOrderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("newClientOrderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cancel_restrictions {
        local_var_req_builder = local_var_req_builder.query(&[("cancelRestrictions", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3OrderDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Check an order's status.  - Either `orderId` or `origClientOrderId` must be sent. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 4
pub async fn api_v3_order_get(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, order_id: Option<i64>, orig_client_order_id: Option<&str>, recv_window: Option<i64>) -> Result<models::OrderDetails, Error<ApiV3OrderGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/order", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("symbol", &symbol.to_string())]);
    if let Some(ref local_var_str) = order_id {
        local_var_req_builder = local_var_req_builder.query(&[("orderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = orig_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("origClientOrderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3OrderGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Cancel an entire Order List  Canceling an individual leg will cancel the entire OCO  Weight(IP): 1
pub async fn api_v3_order_list_delete(configuration: &configuration::Configuration, symbol: &str, timestamp: i64, signature: &str, order_list_id: Option<i64>, list_client_order_id: Option<&str>, new_client_order_id: Option<&str>, recv_window: Option<i64>) -> Result<models::OcoOrder, Error<ApiV3OrderListDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/orderList", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("symbol", &symbol.to_string())]);
    if let Some(ref local_var_str) = order_list_id {
        local_var_req_builder = local_var_req_builder.query(&[("orderListId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = list_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("listClientOrderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("newClientOrderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3OrderListDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves a specific OCO based on provided optional parameters  Weight(IP): 4
pub async fn api_v3_order_list_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, order_list_id: Option<i64>, orig_client_order_id: Option<&str>, recv_window: Option<i64>) -> Result<models::ApiV3OrderListGet200Response, Error<ApiV3OrderListGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/orderList", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = order_list_id {
        local_var_req_builder = local_var_req_builder.query(&[("orderListId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = orig_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("origClientOrderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3OrderListGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Send in a new OCO  - Price Restrictions:   - `SELL`: Limit Price > Last Price > Stop Price   - `BUY`: Limit Price < Last Price < Stop Price - Quantity Restrictions:     - Both legs must have the same quantity     - `ICEBERG` quantities however do not have to be the same - Order Rate Limit     - `OCO` counts as 2 orders against the order rate limit.  Weight(IP): 1
pub async fn api_v3_order_oco_post(configuration: &configuration::Configuration, symbol: &str, side: &str, quantity: f64, price: f64, stop_price: f64, timestamp: i64, signature: &str, list_client_order_id: Option<&str>, limit_client_order_id: Option<&str>, limit_strategy_id: Option<i64>, limit_strategy_type: Option<i64>, limit_iceberg_qty: Option<f64>, trailing_delta: Option<f64>, stop_client_order_id: Option<&str>, stop_strategy_id: Option<i64>, stop_strategy_type: Option<i64>, stop_limit_price: Option<f64>, stop_iceberg_qty: Option<f64>, stop_limit_time_in_force: Option<&str>, new_order_resp_type: Option<&str>, self_trade_prevention_mode: Option<&str>, recv_window: Option<i64>) -> Result<models::ApiV3OrderOcoPost200Response, Error<ApiV3OrderOcoPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/order/oco", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("symbol", &symbol.to_string())]);
    if let Some(ref local_var_str) = list_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("listClientOrderId", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("side", &side.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("quantity", &quantity.to_string())]);
    if let Some(ref local_var_str) = limit_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("limitClientOrderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit_strategy_id {
        local_var_req_builder = local_var_req_builder.query(&[("limitStrategyId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit_strategy_type {
        local_var_req_builder = local_var_req_builder.query(&[("limitStrategyType", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("price", &price.to_string())]);
    if let Some(ref local_var_str) = limit_iceberg_qty {
        local_var_req_builder = local_var_req_builder.query(&[("limitIcebergQty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trailing_delta {
        local_var_req_builder = local_var_req_builder.query(&[("trailingDelta", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stop_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("stopClientOrderId", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("stopPrice", &stop_price.to_string())]);
    if let Some(ref local_var_str) = stop_strategy_id {
        local_var_req_builder = local_var_req_builder.query(&[("stopStrategyId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stop_strategy_type {
        local_var_req_builder = local_var_req_builder.query(&[("stopStrategyType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stop_limit_price {
        local_var_req_builder = local_var_req_builder.query(&[("stopLimitPrice", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stop_iceberg_qty {
        local_var_req_builder = local_var_req_builder.query(&[("stopIcebergQty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stop_limit_time_in_force {
        local_var_req_builder = local_var_req_builder.query(&[("stopLimitTimeInForce", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_order_resp_type {
        local_var_req_builder = local_var_req_builder.query(&[("newOrderRespType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = self_trade_prevention_mode {
        local_var_req_builder = local_var_req_builder.query(&[("selfTradePreventionMode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3OrderOcoPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Send in a new order.  - `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker. - `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached. - Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`. - Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`. - `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price. - `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`. - `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`. - same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.  Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:  - Price above market price: `STOP_LOSS` `BUY`, `TAKE_PROFIT` `SELL` - Price below market price: `STOP_LOSS` `SELL`, `TAKE_PROFIT` `BUY`   Weight(IP): 1
pub async fn api_v3_order_post(configuration: &configuration::Configuration, symbol: &str, side: &str, r#type: &str, timestamp: i64, signature: &str, time_in_force: Option<&str>, quantity: Option<f64>, quote_order_qty: Option<f64>, price: Option<f64>, new_client_order_id: Option<&str>, strategy_id: Option<i64>, strategy_type: Option<i64>, stop_price: Option<f64>, trailing_delta: Option<f64>, iceberg_qty: Option<f64>, new_order_resp_type: Option<&str>, self_trade_prevention_mode: Option<&str>, recv_window: Option<i64>) -> Result<models::ApiV3OrderPost200Response, Error<ApiV3OrderPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/order", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("symbol", &symbol.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("side", &side.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("type", &r#type.to_string())]);
    if let Some(ref local_var_str) = time_in_force {
        local_var_req_builder = local_var_req_builder.query(&[("timeInForce", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quantity {
        local_var_req_builder = local_var_req_builder.query(&[("quantity", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quote_order_qty {
        local_var_req_builder = local_var_req_builder.query(&[("quoteOrderQty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = price {
        local_var_req_builder = local_var_req_builder.query(&[("price", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("newClientOrderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = strategy_id {
        local_var_req_builder = local_var_req_builder.query(&[("strategyId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = strategy_type {
        local_var_req_builder = local_var_req_builder.query(&[("strategyType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stop_price {
        local_var_req_builder = local_var_req_builder.query(&[("stopPrice", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trailing_delta {
        local_var_req_builder = local_var_req_builder.query(&[("trailingDelta", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = iceberg_qty {
        local_var_req_builder = local_var_req_builder.query(&[("icebergQty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_order_resp_type {
        local_var_req_builder = local_var_req_builder.query(&[("newOrderRespType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = self_trade_prevention_mode {
        local_var_req_builder = local_var_req_builder.query(&[("selfTradePreventionMode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3OrderPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.  Weight(IP):    - Without computeCommissionRates: `1`   - With computeCommissionRates: `20`
pub async fn api_v3_order_test_post(configuration: &configuration::Configuration, symbol: &str, side: &str, r#type: &str, timestamp: i64, signature: &str, time_in_force: Option<&str>, quantity: Option<f64>, quote_order_qty: Option<f64>, price: Option<f64>, new_client_order_id: Option<&str>, strategy_id: Option<i64>, strategy_type: Option<i64>, stop_price: Option<f64>, trailing_delta: Option<f64>, iceberg_qty: Option<f64>, new_order_resp_type: Option<&str>, recv_window: Option<i64>, compute_commission_rates: Option<bool>) -> Result<serde_json::Value, Error<ApiV3OrderTestPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/order/test", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("symbol", &symbol.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("side", &side.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("type", &r#type.to_string())]);
    if let Some(ref local_var_str) = time_in_force {
        local_var_req_builder = local_var_req_builder.query(&[("timeInForce", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quantity {
        local_var_req_builder = local_var_req_builder.query(&[("quantity", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quote_order_qty {
        local_var_req_builder = local_var_req_builder.query(&[("quoteOrderQty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = price {
        local_var_req_builder = local_var_req_builder.query(&[("price", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("newClientOrderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = strategy_id {
        local_var_req_builder = local_var_req_builder.query(&[("strategyId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = strategy_type {
        local_var_req_builder = local_var_req_builder.query(&[("strategyType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stop_price {
        local_var_req_builder = local_var_req_builder.query(&[("stopPrice", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trailing_delta {
        local_var_req_builder = local_var_req_builder.query(&[("trailingDelta", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = iceberg_qty {
        local_var_req_builder = local_var_req_builder.query(&[("icebergQty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_order_resp_type {
        local_var_req_builder = local_var_req_builder.query(&[("newOrderRespType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = compute_commission_rates {
        local_var_req_builder = local_var_req_builder.query(&[("computeCommissionRates", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3OrderTestPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Displays the user's current order count usage for all intervals.  Weight(IP): 40
pub async fn api_v3_rate_limit_order_get(configuration: &configuration::Configuration, timestamp: i64, signature: &str, recv_window: Option<i64>) -> Result<Vec<models::ApiV3RateLimitOrderGet200ResponseInner>, Error<ApiV3RateLimitOrderGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/rateLimit/order", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3RateLimitOrderGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Weight(IP): 6
pub async fn api_v3_sor_order_post(configuration: &configuration::Configuration, symbol: &str, side: &str, r#type: &str, quantity: f64, timestamp: i64, signature: &str, time_in_force: Option<&str>, price: Option<f64>, new_client_order_id: Option<&str>, strategy_id: Option<i64>, strategy_type: Option<i64>, iceberg_qty: Option<f64>, new_order_resp_type: Option<&str>, self_trade_prevention_mode: Option<&str>, recv_window: Option<i64>) -> Result<models::ApiV3SorOrderPost200Response, Error<ApiV3SorOrderPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/sor/order", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("symbol", &symbol.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("side", &side.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("type", &r#type.to_string())]);
    if let Some(ref local_var_str) = time_in_force {
        local_var_req_builder = local_var_req_builder.query(&[("timeInForce", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("quantity", &quantity.to_string())]);
    if let Some(ref local_var_str) = price {
        local_var_req_builder = local_var_req_builder.query(&[("price", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("newClientOrderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = strategy_id {
        local_var_req_builder = local_var_req_builder.query(&[("strategyId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = strategy_type {
        local_var_req_builder = local_var_req_builder.query(&[("strategyType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = iceberg_qty {
        local_var_req_builder = local_var_req_builder.query(&[("icebergQty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_order_resp_type {
        local_var_req_builder = local_var_req_builder.query(&[("newOrderRespType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = self_trade_prevention_mode {
        local_var_req_builder = local_var_req_builder.query(&[("selfTradePreventionMode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3SorOrderPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.  Weight(IP):    - Without computeCommissionRates: `1`   - With computeCommissionRates: `20`
pub async fn api_v3_sor_order_test_post(configuration: &configuration::Configuration, symbol: &str, side: &str, r#type: &str, quantity: f64, timestamp: i64, signature: &str, time_in_force: Option<&str>, price: Option<f64>, new_client_order_id: Option<&str>, strategy_id: Option<i64>, strategy_type: Option<i64>, iceberg_qty: Option<f64>, new_order_resp_type: Option<&str>, self_trade_prevention_mode: Option<&str>, compute_commission_rates: Option<bool>, recv_window: Option<i64>) -> Result<serde_json::Value, Error<ApiV3SorOrderTestPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v3/sor/order/test", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("symbol", &symbol.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("side", &side.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("type", &r#type.to_string())]);
    if let Some(ref local_var_str) = time_in_force {
        local_var_req_builder = local_var_req_builder.query(&[("timeInForce", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("quantity", &quantity.to_string())]);
    if let Some(ref local_var_str) = price {
        local_var_req_builder = local_var_req_builder.query(&[("price", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_client_order_id {
        local_var_req_builder = local_var_req_builder.query(&[("newClientOrderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = strategy_id {
        local_var_req_builder = local_var_req_builder.query(&[("strategyId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = strategy_type {
        local_var_req_builder = local_var_req_builder.query(&[("strategyType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = iceberg_qty {
        local_var_req_builder = local_var_req_builder.query(&[("icebergQty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_order_resp_type {
        local_var_req_builder = local_var_req_builder.query(&[("newOrderRespType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = self_trade_prevention_mode {
        local_var_req_builder = local_var_req_builder.query(&[("selfTradePreventionMode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = compute_commission_rates {
        local_var_req_builder = local_var_req_builder.query(&[("computeCommissionRates", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recv_window {
        local_var_req_builder = local_var_req_builder.query(&[("recvWindow", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("timestamp", &timestamp.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("signature", &signature.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-MBX-APIKEY", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV3SorOrderTestPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

